[{"name": "app.py", "content": "import matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.ticker as ticker\n\nfrom functools import partial\nfrom shiny.ui import page_navbar\nfrom shiny.express import render, ui, input\nfrom shiny import reactive\n\nfrom matplotlib import cbook\n#Variaveis de design\npontos = '#0023FF'\npalavras = '#FFC400'\nmedia_cor = '#FFC400'\ngrafico1 = '#0023FF'\ngrafico2 = '#FFC400'\n\nui.page_opts(\n    title= \"Cienvolva\",  \n    #page_fn=partial(page_navbar, id=\"page\"),  \n    fillable=True\n)\n\ndef tratamento (novo): #Tratamento dos dados de horarios\n  horarios = []\n\n  for i in range(0, len(novo)): #Para qualquer separador, usa apenas os : para se basear\n    if novo[i] == ':':\n      horarios.append(novo[i-2:i+3])\n\n  for i in range(0,len(horarios)): #Para corrigir horarios como 4:15 para 04:15\n    if horarios[i][0] == ' ':\n      horarios[i] = '0'+horarios[i].strip()\n\n  #Transforma os horarios no formato de decimais\n  valores  = []\n\n  for horario in horarios:\n      hora, min = horario.split(\":\")\n      min = int(min)/60\n      valores.append (int(hora) + min)\n\n  for i in range(len(valores)): #Elimina valores como 24:15\n      valores[i] %= 24\n\n  if valores == []:\n    valores = [0]\n  return valores\n\ndef hist_vertical(valores, duracao, foco, escalaAutomatica):\n  #Seleciona o tamanho de intevalos como um int\n  '''duracao = duracao.split()\n  duracao = int(duracao[0])\n  if duracao == 1:\n    duracao = 60'''\n\n  escala = 60/duracao\n  passo = 1/escala\n\n  if escalaAutomatica:\n    distribuicao = [0]*24*int(escala) #Numero de bins caso a escala seja automatica\n\n    for valor in valores:\n      valor %= 24\n      valor *= escala\n      distribuicao[int((valor//1))] += 1 #Seleciona o bin especifico onde cabe aquele valor e adiciona +1\n      valor /= escala\n\n\n  else:\n    distribuicao = [0]*24 #Se n\u00e3o seria o mesmo que escala = 1\n\n    for valor in valores:\n      valor %= 24\n      distribuicao[int((valor//1))] += 1\n\n  eixo_y = max(distribuicao) + 1 #Distribui\u00e7\u00e3o faz o trabalho manual do histograma para descobrir o valor m\u00e1ximo em y\n\n  #Formata os major positions - inteiros e de 0 a 23 e os minor positions -- dependem da escala (0,5 0,25 ou 0,75)\n  #Essas ser\u00e3o as posi\u00e7\u00f5es que os horarios entar\u00e3o na tela\n  major_positions=list(range(0,24))\n  minor_positions=[]\n  cont =1\n  #Major_positions s\u00e3o as horas, passa por todas as horas e adiciona em minor_positions todas as divis\u00f5es necess\u00e1rias\n  for major_position in major_positions:\n      while cont < escala:\n        minor_positions.append(major_position+cont*passo)\n        cont+=1\n      cont=1\n\n  #Formata os ticks que aparecem na tela como horas\n  major_hora = []\n  minor_hora = []\n  cont = 1\n  i=0\n  while len(major_hora)<24:\n    major_hora.append(str(i)+':'+\"00\")\n    while cont<escala:\n      if cont*duracao == 30:\n        minor_hora.append(str(i)+\":30\")\n      else:\n        minor_hora.append('')\n      cont+=1\n    cont=1\n    i+=1\n\n  ##A partir daqui: Cria\u00e7\u00e3o e formata\u00e7\u00e3o do gr\u00e1fico\n  # plot:\n  fig, ax = plt.subplots(figsize=(14,5))\n\n  bins = []\n  cont = 0\n  #Cria as bins como uma lista com todas as divis\u00f5es\n  for i in range(0,25):\n    bins.append(i)\n    while cont < escala:\n        bins.append(bins[len(bins)-1]+(passo))\n        cont+=1\n    cont=1\n\n  ax.hist(valores, bins,width=passo, linewidth=0.5, edgecolor=\"white\", color = grafico1)#valores = valores a serem sorteados, bins = quais as divis\u00f5es\n\n  #formata os ticks\n  ax.tick_params(which='major', labelsize= 8, width=1.0, length=9)\n  ax.tick_params(which='minor', labelsize = 5,  width=0.75, length=2.5)\n\n  #Fixa a posi\u00e7\u00e3o dos ticks nos eixos\n  ax.xaxis.set_major_locator(ticker.FixedLocator(major_positions))\n  ax.xaxis.set_major_formatter(ticker.FixedFormatter(major_hora))\n\n  #Fixa o valor dos ticks no eixo\n  ax.xaxis.set_minor_locator(ticker.FixedLocator(minor_positions))\n  ax.xaxis.set_minor_formatter(ticker.FixedFormatter(minor_hora))\n\n  ax.set(xlim=(-0.5, 24.5*passo), xticks=np.arange(0, 24.5),\n        ylim=(0, eixo_y), yticks=np.arange(0, eixo_y))\n  \n  altura = 0\n  for valor in valores:\n    if valor >= foco and valor < foco+duracao/60:\n      altura += 1\n  \n  plt.plot([-0.5,foco], [altura]*2, color = \"orange\", linestyle = \":\")\n  ax.bar(foco, altura, color = \"orange\", align = \"edge\", width = duracao/60)\n\n  plt.show()\n\nwith ui.nav_panel(\"Hor\u00e1rios de \u00d4nibus\"):  \n    #Sidebar com menu de um gr\u00e1fico \u00fanico, cria\u00e7\u00e3o no gr\u00e1fico no main tab\n    with ui.layout_columns(col_widths=(4,8)):\n      with ui.navset_card_tab():\n        with ui.nav_panel(\" \", icon= \"\ud83c\udfe0\ufe0e\"):  \n          ui.markdown(\"\"\"&emsp; Para come\u00e7ar precisamos de hor\u00e1rios de \u00f4nibus!\n                      <br> &emsp; Voc\u00ea pode conseguir hor\u00e1rios reais no [site \u00f4nibus de Joinville](https://onibus.info/linhas) basta escolher uma linha qualquer, copiar todos os hor\u00e1rios do site e colar na caixa de texto como no exemplo\\\n                      <br><br>\"\"\")\n          \n          #Caixa de texto p/ horarios\n          ui.input_text_area(\"text\", \"Insira os hor\u00e1rios\", placeholder= \"00:00 \\n01:00 \\n01:15...\") \n          def min_horas(min):\n            horas = min/60\n            return horas\n          ui.markdown(\"\"\"\n                      <br> &emsp; Se n\u00e3o conseguir buscar os hor\u00e1rios n\u00e3o tem problema, basta inventar alguns seguindo a l\u00f3gica do exemplo.\n                      <br><br>\n                      &emsp;Navegue pelos hor\u00e1rios mudando a op\u00e7\u00e3o de *hor\u00e1rio pretendido* \u00e0 esquerda, e observe os destaques no gr\u00e1fico :) <br>\"\"\")\n          #Slider de foco\n          ui.input_slider(\"slider\", \"Selecione o foco\", min = 0, max = 24, value = 6, step = 1, post = \" horas\")\n          \n          ui.markdown(\"\"\"<br>&emsp;Voc\u00ea pode escolher tamb\u00e9m o *intervalo* de quantos minutos quiser a partir da hora pretendida.<br><br>\"\"\")\n          #Lista p/ dura\u00e7\u00e3o\n          ui.input_radio_buttons(\"duracao\", \"Selecione o intervalo\",\n                                 {\"15\": \"15 minutos\", \"30\": \"30 minutos\", \"60\": \"1 hora\"}, \n                                 selected = \"60\")\n          ui.markdown(\"\"\"<br>&emsp;Experimentou diminuir o intervalo?!\n                        <br>&emsp;A altura das barras vai diminuindo: natural, n\u00e3o \u00e9?! \n                        <br>&emsp;Em intervalos menores que 1 hora geralmente v\u00e3o sair menos \u00f4nibus que em 1 hora, e a diminui\u00e7\u00e3o de altura das barras expressa isso :)<br>\n                        <br>&emsp;Por outro lado, isso pode dificultar um pouco a leitura, al\u00e9m de ficar bastante espa\u00e7o vazio no gr\u00e1fico, concorda?!\n                        <br> &emsp;O que a gente poderia fazer pra melhorar essa visualiza\u00e7\u00e3o com intervalo menor e tirar esse espa\u00e7o vazio?\u2026<br><br>\"\"\")\n          #Check p/ ajustar propor\u00e7\u00e3o\n          ui.input_checkbox(\"check\", \"Ajustar a escala\", value = False)\n          ui.markdown(\"\"\"<br>Experimente *ajustar a escala* e observe o que acontece\u2026\n                      <br><br>Pronto! :D\n                      <br>Agora voc\u00ea conhece todas as funcionalidades dessa aba, pode interpretar o gr\u00e1fico para ter as informa\u00e7\u00f5es que quiser \u2014 pelo menos de quantos \u00f4nibus saem numa certa faixa de hor\u00e1rio\u2026\n                      <br>Se quiser continuar explorando nossas interatividades experimente a aba *Playground* onde voc\u00ea pode vizualizar melhor as fun\u00e7\u00f5es\n                      <ul>\n                      <br><br><li> Quer testar seu conhecimento?! \n                          <br>&emsp;--> explore nosso painel de perguntas!\n                      <br> <li> Quer explorar mais as diferen\u00e7as de intervalos?!\n                      <br>&emsp;--> selecione *Comparativo* no topo da p\u00e1gina!\n                      <br><li> Quer ter uma ideia do tempo de espera pra uma faixa de hor\u00e1rio?! \n                      <br>&emsp;--> selecione *Tempo de espera* no topo da p\u00e1gina!\n                      <br><li> Quer contar pra gente como foi pra voc\u00ea passear por aqui?! \n                      <br>&emsp;--> [clique aqui](link do formul\u00e1rio de satisfa\u00e7\u00e3o)!\n                      <ul>\"\"\")\n\n        with ui.nav_panel(\"Playground\"):\n          #Caixa de texto p/ horarios\n          ui.input_text_area(\"text\", \"Insira os hor\u00e1rios\", placeholder= \"00:00 \\n01:00 \\n01:15...\")\n          #Slider de foco\n          ui.input_slider(\"slider\", \"Selecione o foco\", min = 0, max = 24, value = 6, step = 1, post = \" horas\")\n          #Lista p/ dura\u00e7\u00e3o\n          ui.input_radio_buttons(\"duracao\", \"Selecione o intervalo\",\n                                 {\"15\": \"15 minutos\", \"30\": \"30 minutos\", \"60\": \"1 hora\"}, \n                                 selected = \"60\")\n          #Check p/ ajustar propor\u00e7\u00e3o\n          ui.input_checkbox(\"check\", \"Ajustar a escala\", value = False)\n        with ui.nav_panel(\"Perguntas\"):\n          \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed sagittis metus sed lacinia aliquet. Praesent vestibulum tortor id libero blandit, in ultrices leo vestibulum. Maecenas lobortis, odio vel eleifend malesuada, elit urna semper dolor, auctor sagittis neque nulla nec nulla. Maecenas bibendum imperdiet justo, in aliquam nisi sodales quis. Quisque aliquam, sem eget elementum accumsan, nisl sem ullamcorper odio, ut consequat odio lectus at purus. Aenean lectus nisi, auctor quis venenatis eu, aliquam commodo velit. Etiam quis ex et magna pellentesque pretium vel non velit. Mauris a lobortis neque. Quisque malesuada justo a faucibus posuere. Curabitur sed vestibulum ipsum, ut consequat nisl. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec eget justo nulla. Vestibulum ut odio feugiat, euismod ligula scelerisque, congue mi. Vivamus cursus augue quis ante vulputate lacinia. Proin non fermentum massa, pharetra ultrices eros.\"\n      with ui.card():\n        \"Aqui a gente visualiza como os hor\u00e1rios desse \u00f4nibus est\u00e3o distribu\u00eddos ao longo do dia: \"\n        @render.plot()\n        #@reactive.event(input.button)\n        def graf():\n          if input.text() == \"\":\n            return\n          else:\n            return hist_vertical(valores=tratamento(novo = input.text()), duracao = int(input.duracao()), foco = input.slider(), escalaAutomatica = input.check())\n\n        ui.markdown(\"\"\"<br>&emsp;Entre <hor\u00e1rio pretendido> e <hor\u00e1rio pretendido + intervalo>, saem < contagem no intervalo> \u00f4nibus\"\"\")        \n#Histograma comparativo\n#Aqui est\u00e1 todo o processamento para formatar e criar um gr\u00e1fico com dois histogramas lado a lado\ndef hist_horizontal_comparativo(valores, duracao1, duracao2, mesmaEscala):\n\n  #Defini\u00e7\u00f5es histograma esquerda\n\n  #duracao1 = duracao1.split()\n  #duracao1 = int(duracao1[0])\n  #if duracao1 == 1:\n  # duracao1 = 60\n\n  escala1 = 60/duracao1\n  passo = 1/escala1\n\n  #Cria as bins como uma lista com todas as divis\u00f5es\n  bins =[]\n  cont = 1\n  for i in range(0,25):\n    bins.append(i)\n    while cont < escala1:\n        bins.append(bins[len(bins)-1]+(passo))\n        cont+=1\n    cont=1\n\n  #Fim defini\u00e7\u00f5es histograma esquerda\n\n  #Defini\u00e7\u00f5es histograma direita\n  #duracao2 = duracao2.split()\n  #duracao2 = int(duracao2[0])\n  #if duracao2 == 1:\n  #  duracao2 = 60\n\n  escala2 = 60/duracao2\n  passo = 1/escala2\n\n  bins2 =[]\n  cont = 1\n  for i in range(0,25):\n    bins2.append(i)\n    while cont < escala2:\n        bins2.append(bins2[len(bins2)-1]+(passo))\n        cont+=1\n    cont=1\n\n  #fim defini\u00e7\u00f5es histograma direita\n\n  escala = min(escala1,escala2)\n\n  #Escala autom\u00e1tica\n  if mesmaEscala:\n    #encaixa os valores de horarios em suas posi\u00e7\u00f5es dependendo do proprio horario\n    distribuicao = [0]*24*int(escala)\n\n    for valor in valores:\n      valor %= 24\n      valor *= escala\n      distribuicao[int((valor//1))] += 1\n      valor /= escala\n    distribuicao2 = distribuicao.copy()\n    distribuicao1 = distribuicao.copy()\n  else:\n    distribuicao1 = [0]*24*int(escala1)\n    distribuicao2 = [0]*24*int(escala2)\n    for valor in valores:\n      valor %= 24\n      valor *= escala1\n      distribuicao1[int((valor//1))] += 1\n      valor /= escala1\n      valor *= escala2\n      distribuicao2[int((valor//1))] += 1\n      valor /= escala2\n\n  eixo_x1 = max(distribuicao1) + 1\n  eixo_x2 = max(distribuicao2) + 1\n\n\n  #Igual para ambos\n  escala = max(escala1,escala2)\n  duracao = 60/escala\n  passo = 1/escala\n  #Formata os major positions - inteiros e de 0 a 23 e os minor positions -- dependem da escala (0,5 0,25 ou 0,75)\n  major_positions=list(range(0,25))\n  minor_positions=[]\n  cont = 1\n  for major_position in major_positions:\n      while cont < escala:\n        minor_positions.append(major_position+cont*passo)\n        cont+=1\n      cont=1\n\n  #Formata os ticks que aparecem na tela como horas\n  major_hora = []\n  minor_hora = []\n  cont = 1\n  i=0\n  while len(major_hora)<=24:\n    major_hora.append(str(i)+':'+\"00\")\n\n    if len(major_hora)<=24:\n      while cont<escala:\n        if cont*duracao == 30:\n          minor_hora.append(str(i)+\":30\")\n        else:\n          minor_hora.append('')\n        cont+=1\n    cont=1\n    i+=1\n  # plot:\n  #fig = plt.figure(figsize=(8,10), facecolor='lightblue')\n  #ax[0] = fig.add_axes([2,4,2,8])\n  #ax[1] = fig.add_axes([4,6,2,8])\n  fig, ax = plt.subplots(1,2,figsize=(8,10), sharey=True)\n\n  #Histograma esquerdo\n  #Cria o histograma na horizontal esquerdo\n  ax[0].hist(valores, bins, height=1/escala1,weights=-np.ones_like(valores), linewidth=0.5, edgecolor=\"white\", orientation = \"horizontal\", color = grafico2)#valores = valores a serem sorteados, bins = quais as divis\u00f5es\n  #Habilita o grid\n  ax[0].grid(visible = True, which = 'major', axis = 'y')\n\n  #formata os ticks\n  ax[0].tick_params(which='major', labelsize= 10, width=1.0, length=7)\n  ax[0].tick_params(which='minor', labelsize = 8,  width=0.75, length=2.5)\n\n  #Fixa a posi\u00e7\u00e3o dos ticks\n  ax[0].yaxis.set_major_locator(ticker.FixedLocator(major_positions))\n  ax[0].yaxis.set_major_formatter(ticker.FixedFormatter(major_hora))\n\n  #Define o texto dos ticks\n  ax[0].yaxis.set_minor_locator(ticker.FixedLocator(minor_positions))\n  ax[0].yaxis.set_minor_formatter(ticker.FixedFormatter(minor_hora))\n\n  #Arruma o eixo x - pois est\u00e1 negativo\n  ax[0].xaxis.set_major_locator(ticker.FixedLocator(range(-eixo_x1, 0)))\n\n  #Arruma para que todo eixo seja positivo\n  valor  = []\n  for i in range(-eixo_x1, 0):\n    valor.append(abs(i))\n\n  ax[0].xaxis.set_major_formatter(ticker.FixedFormatter(valor))\n\n  ax[0].set_xlim(-eixo_x1, 0)\n  ax[0].set_ylim(-0.5, 24.5)\n\n  #Cria o histograma na horizontal direito\n  ax[1].hist(valores, bins2, height=1/escala2, linewidth=0.5, edgecolor=\"white\", orientation = \"horizontal\", color = grafico1)\n  #Habilita o grid\n  ax[1].grid(visible = True, which = 'major', axis = 'y')\n\n  #formata os ticks\n  ax[1].tick_params(which='major', labelsize= 10, width=1.0, length=7)\n  ax[1].tick_params(which='minor', labelsize = 8,  width=0.75, length=2.5)\n\n  #Fixa a posi\u00e7\u00e3o dos ticks\n  ax[1].yaxis.set_major_locator(ticker.FixedLocator(major_positions))\n  ax[1].yaxis.set_major_formatter(ticker.FixedFormatter(major_hora))\n\n  #Define o texto dos ticks\n  ax[1].yaxis.set_minor_locator(ticker.FixedLocator(minor_positions))\n  ax[1].yaxis.set_minor_formatter(ticker.FixedFormatter(minor_hora))\n\n  #Define a posi\u00e7\u00e3o e valor do eixo x\n  ax[1].xaxis.set_major_locator(ticker.FixedLocator(range(0, eixo_x2+1)))\n  ax[1].xaxis.set_major_formatter(ticker.FixedFormatter(range(0, eixo_x2+1)))\n\n  ax[1].set_xlim(0,eixo_x2)\n  ax[1].set_ylim(-0.5, 24.5)\n\n  # Adjust spacing\n  plt.subplots_adjust(left=0.1, right=0.9,\n                      top=0.9, bottom=0.1,\n                      wspace=0.0) #A dist\u00e2ncia pra ficar s\u00f3 ticks entre eles \u00e9 0.035\n\n  plt.show()                \n\nwith ui.nav_panel(\"Comparativo\"):  \n  #Sidebar com menu de um gr\u00e1fico comparativo, cria\u00e7\u00e3o no gr\u00e1fico no main tab\n  with ui.layout_columns(col_widths=(3,9), row_heights= (12), fill = True):\n    with ui.navset_card_tab():\n      with ui.nav_panel(\"Interativo\"):  \n        #\"Aqui ficar\u00e1 o menu do gr\u00e1fico comparativo\" \n        #Caixa de texto p/ horarios\n        ui.input_text_area(\"text1\", \"Insira os hor\u00e1rios\", placeholder= \"00:00 \\n01:00 \\n01:15...\") \n        #Slider p/ dura\u00e7\u00e3o\n        ui.input_slider(\"slider1\", \"Intervalo do gr\u00e1fico da direita: \", min = 15, max = 60, value = 60, step = 15, post = \" minutos\")\n        #Slider p/dura\u00e7\u00e3o 2\n        ui.input_slider(\"slider2\", \"Intervalo do gr\u00e1fico da esquerda: \", min = 15, max = 60, value = 60, step = 15, post = \" minutos\")\n        #Check p/ ajustar propor\u00e7\u00e3o\n        ui.input_checkbox(\"check1\", \"Ajustar propor\u00e7\u00e3o\", value = False)\n      with ui.nav_panel(\"Explica\u00e7\u00e3o\"):\n        \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed sagittis metus sed lacinia aliquet. Praesent vestibulum tortor id libero blandit, in ultrices leo vestibulum. Maecenas lobortis, odio vel eleifend malesuada, elit urna semper dolor, auctor sagittis neque nulla nec nulla. Maecenas bibendum imperdiet justo, in aliquam nisi sodales quis. Quisque aliquam, sem eget elementum accumsan, nisl sem ullamcorper odio, ut consequat odio lectus at purus. Aenean lectus nisi, auctor quis venenatis eu, aliquam commodo velit. Etiam quis ex et magna pellentesque pretium vel non velit. Mauris a lobortis neque. Quisque malesuada justo a faucibus posuere. Curabitur sed vestibulum ipsum, ut consequat nisl. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec eget justo nulla. Vestibulum ut odio feugiat, euismod ligula scelerisque, congue mi. Vivamus cursus augue quis ante vulputate lacinia. Proin non fermentum massa, pharetra ultrices eros.\"\n      with ui.nav_panel(\"Perguntas\"):\n        \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed sagittis metus sed lacinia aliquet. Praesent vestibulum tortor id libero blandit, in ultrices leo vestibulum. Maecenas lobortis, odio vel eleifend malesuada, elit urna semper dolor, auctor sagittis neque nulla nec nulla. Maecenas bibendum imperdiet justo, in aliquam nisi sodales quis. Quisque aliquam, sem eget elementum accumsan, nisl sem ullamcorper odio, ut consequat odio lectus at purus. Aenean lectus nisi, auctor quis venenatis eu, aliquam commodo velit. Etiam quis ex et magna pellentesque pretium vel non velit. Mauris a lobortis neque. Quisque malesuada justo a faucibus posuere. Curabitur sed vestibulum ipsum, ut consequat nisl. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec eget justo nulla. Vestibulum ut odio feugiat, euismod ligula scelerisque, congue mi. Vivamus cursus augue quis ante vulputate lacinia. Proin non fermentum massa, pharetra ultrices eros.\"\n    with ui.card():\n      #\"Aqui ficar\u00e1 o gr\u00e1fico comparativo\"\n      @render.plot()\n      #@reactive.event(input.button)\n      def graf1():\n        if input.text1() == \"\":\n          return\n        else:\n          return hist_horizontal_comparativo(valores=tratamento(novo = input.text1()), duracao1 = input.slider1(), duracao2 = input.slider2(), mesmaEscala = input.check1())\n\ndef delta_tempo(valores, intervalo):\n\n  #organiza\u00e7\u00e3o dos hor\u00e1rios por ordem crescente\n  valores.sort()\n  if len(valores) == 0:\n    valores = [0]\n  valores = [0]+valores+[24+valores[0]]#Adiciona 0 e 24 mais primeiro valor, pra funcinar nas bordas\n  #Cria\u00e7\u00e3o do gr\u00e1fico e do seu tamanho\n  fig, axes1 = plt.subplots(figsize=(30, 7))\n\n  for i in range(0,len(valores)-1):\n    #Plot de cada subconjunto do gr\u00e1fico com o horario e o horario seguinte sendo o eixo x e o eixo y sendo o valor da diferen\u00e7a at\u00e9 0\n    axes1.plot ([valores[i], valores[i+1]],[(valores[i+1]-valores[i]), 0], color = grafico1)\n\n  duracao = 1\n  escala = 1\n\n  axes2 = axes1.inset_axes(bounds = [.575, .55, .4, .4],zorder=6)\n  #axes1 \u00e9 o gr\u00e1fico maior\n  #axes2 \u00e9 o gr\u00e1fico menor\n\n  #plt.setp(ax, xticks=[], yticks=[])\n  valores_intervalo = [intervalo[0]] #Lista com todos os valores de dentro do intervalo\n  for valor in valores:\n    if valor > intervalo[0] and valor < intervalo[1]:\n      valores_intervalo.append(valor)\n    elif valor >= intervalo[1]:\n      valores_intervalo.append(valor)\n      break\n\n  for i in range(0,len(valores)-1):\n    #Plot de cada subconjunto do gr\u00e1fico com o horario e o horario seguinte sendo o eixo x e o eixo y sendo o valor da diferen\u00e7a at\u00e9 0\n    axes2.plot ([valores[i], valores[i+1]],[(valores[i+1]-valores[i]), 0], color = grafico1)\n    #Plot de pontos na absissa de cada horario em que sai um onibus\n    axes2.plot (valores[i],0, marker = 'o', color = pontos)\n\n  media = sum([(valores_intervalo[i+1]-valores_intervalo[i])**2/2 for i in range(len(valores_intervalo)-1)]) #soma dos valores de dentro do intervalo\n  media -= (valores_intervalo[-1] - intervalo[1])**2/2 #Tirar o triangulo do final\n  media /= (intervalo[1]-intervalo[0]) #Dividido pela \u00e1rea\n\n\n  #Plot da linha de m\u00e9dia\n  axes2.plot((intervalo[0], intervalo[-1]), [media]*2, color = media_cor)\n\n  #Formata os ticks que aparecem na tela como horas\n  #Posi\u00e7\u00e3o das horas\n  major_positions=list(range(0,25))\n  cont =1\n  major_positions2 = list(range(0,25))\n  minor_positions2 = []\n  #Major_positions s\u00e3o as horas, passa por todas as horas e adiciona em minor_positions todas as divis\u00f5es necess\u00e1rias\n  for major_position in major_positions2:\n      while cont < 1:\n        minor_positions2.append(major_position+cont*0.5)\n        cont+=1\n      cont=1\n\n  #Valores que aparecem na tela\n  major_hora = []\n  minor_hora = []\n  i=0\n\n  while len(major_hora)<25:\n    major_hora.append(str(i)+':'+\"00\")\n    i+=1\n\n  #seta os ticks do gr\u00e1fico maior no formato\n  axes1.tick_params(which='major', labelsize= 10, width=1.0, length=9)\n  axes1.tick_params(which='minor', labelsize = 8,  width=0.75, length=2.5)\n\n  #Fixa a posi\u00e7\u00e3o dos ticks nos eixos do gr\u00e1fico maior\n  axes1.xaxis.set_major_locator(ticker.FixedLocator(major_positions))\n  axes1.xaxis.set_major_formatter(ticker.FixedFormatter(major_hora))\n\n  #formata os ticks do gr\u00e1fico menor\n  axes2.tick_params(which='major', labelsize= 10, width=1.0, length=9)\n  axes2.tick_params(which='minor', labelsize = 8,  width=0.75, length=2.5)\n\n  max_y = []\n  for i  in range(len(valores)-1):\n    if valores[i] >= intervalo[0] and valores[i] <= intervalo[-1]:\n      if len(max_y) == 0:\n        max_y.append(valores[i] - intervalo[0])\n      else:\n        max_y.append(valores[i+1]-valores[i])\n\n  i=0\n  while valores[i]<intervalo[-1]:\n    i += 1\n\n  if max_y == []:\n    max_y = [0,max(valores[i]-intervalo[0],media)]\n  axes2.set_ylim(0, max(max_y)+max(max_y)/10)\n  axes2.set_xlim(intervalo[0], intervalo[-1])\n\n  axes2.text(intervalo[0],(media + (max(max_y)/40)), \" Tempo m\u00e9dio de espera no intervalo selecionado\", color = palavras)\n\n  def float_para_hora(y, pos):\n    return f'{int(y):02d}:{int((y-int(y))*60):02d}'\n\n  axes2.yaxis.set_major_formatter(float_para_hora)\n  axes1.yaxis.set_major_formatter(float_para_hora)\n\n  axes2.xaxis.set_major_formatter(float_para_hora)\n\n  max_y = []\n  for i in range(0,len(valores)-1):\n    max_y.append(valores[i+1]-valores[i])\n  if max_y == []:\n    max_y = [0,24]\n  axes1.set_ylim(0,max(max_y)+max(max_y)/10)\n  axes1.set_xlim(0, 24.5)\n\n  #Indicadores s\u00e3o as linhas que ligam o gr\u00e1fico menor e a maior\n  indicadores =  axes1.indicate_inset_zoom(inset_ax = axes2, edgecolor='black')\n\n  plt.show()\n\n\nwith ui.nav_panel(\"Tempo de espera\"):  \n  #Sidebar com menu de um gr\u00e1fico de tempo de espera, cria\u00e7\u00e3o no gr\u00e1fico no main tab\n  with ui.layout_columns(col_widths=(3,9)):\n    with ui.navset_card_tab(): \n      with ui.nav_panel(\"Interativo\"):\n        #\"Aqui ficar\u00e1 o menu do gr\u00e1fico de tempo de espera\"  \n        ui.input_text_area(\"text2\", \"Insira os hor\u00e1rios: \", placeholder = \"00:00 \\n01:00 \\n02:00 ...\")\n        ui.input_slider(\"range\", \"Intervalo\", min=0, max= 24, value = [00, 24], step = 0.5)\n      with ui.nav_panel(\"Explica\u00e7\u00e3o\"):\n        \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed sagittis metus sed lacinia aliquet. Praesent vestibulum tortor id libero blandit, in ultrices leo vestibulum. Maecenas lobortis, odio vel eleifend malesuada, elit urna semper dolor, auctor sagittis neque nulla nec nulla. Maecenas bibendum imperdiet justo, in aliquam nisi sodales quis. Quisque aliquam, sem eget elementum accumsan, nisl sem ullamcorper odio, ut consequat odio lectus at purus. Aenean lectus nisi, auctor quis venenatis eu, aliquam commodo velit. Etiam quis ex et magna pellentesque pretium vel non velit. Mauris a lobortis neque. Quisque malesuada justo a faucibus posuere. Curabitur sed vestibulum ipsum, ut consequat nisl. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec eget justo nulla. Vestibulum ut odio feugiat, euismod ligula scelerisque, congue mi. Vivamus cursus augue quis ante vulputate lacinia. Proin non fermentum massa, pharetra ultrices eros.\"\n      with ui.nav_panel(\"Fixa\u00e7\u00e3o\"):\n        \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed sagittis metus sed lacinia aliquet. Praesent vestibulum tortor id libero blandit, in ultrices leo vestibulum. Maecenas lobortis, odio vel eleifend malesuada, elit urna semper dolor, auctor sagittis neque nulla nec nulla. Maecenas bibendum imperdiet justo, in aliquam nisi sodales quis. Quisque aliquam, sem eget elementum accumsan, nisl sem ullamcorper odio, ut consequat odio lectus at purus. Aenean lectus nisi, auctor quis venenatis eu, aliquam commodo velit. Etiam quis ex et magna pellentesque pretium vel non velit. Mauris a lobortis neque. Quisque malesuada justo a faucibus posuere. Curabitur sed vestibulum ipsum, ut consequat nisl. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec eget justo nulla. Vestibulum ut odio feugiat, euismod ligula scelerisque, congue mi. Vivamus cursus augue quis ante vulputate lacinia. Proin non fermentum massa, pharetra ultrices eros.\"          \n    with ui.card():\n      #\"Aqui ficar\u00e1 o gr\u00e1fico de tempo de espera\"\n      @render.plot()\n      #@reactive.event(input.button)\n      def graf2():\n        if input.text2() == \"\":\n          return\n        else:\n          return delta_tempo(valores = tratamento(input.text2()), intervalo = input.range())", "type": "text"}, {"name": "Onibus.py", "content": "# @title C\u00f3digo\n# @markdown Pressione o bot\u00e3o \u00b4Play\u00b4 ao lado para executar o aplicativo\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.ticker as ticker\nfrom ipywidgets import interact, interactive, fixed, interact_manual\nimport ipywidgets as widgets\n\n\n#Variaveis de design\npontos = '#0023FF'\npalavras = '#FFC400'\nmedia_cor = '#FFC400'\ngrafico1 = '#0023FF'\ngrafico2 = '#FFC400'\n\n#Tratamento do input de horarios\n## -- Recebe e formata os valores -- recebe horarios e retorna os valores em decimais\n#Salva input de horarios em uma lista\ndef tratamento (novo):\n  horarios = []\n\n  for i in range(0, len(novo)): #Para qualquer separador, usa apenas os : para se basear\n    if novo[i] == ':':\n      horarios.append(novo[i-2:i+3])\n\n  for i in range(0,len(horarios)): #Para corrigir horarios como 4:15 para 04:15\n    if horarios[i][0] == ' ':\n      horarios[i] = '0'+horarios[i].strip()\n\n  #Transforma os horarios no formato de decimais\n  valores  = []\n\n  for horario in horarios:\n      hora, min = horario.split(\":\")\n      min = int(min)/60\n      valores.append (int(hora) + min)\n\n  for i in range(len(valores)): #Elimina valores como 24:15\n      valores[i] %= 24\n\n  if valores == []:\n    valores = [0]\n  return valores\n#Histograma vertical\n#Aqui cont\u00e9m todo processamento necess\u00e1rio para criar e formatar um histograma \u00fanico\n\ndef hist_vertical(valores, duracao, escalaAutomatica):\n  #Seleciona o tamanho de intevalos como um int\n  duracao = duracao.split()\n  duracao = int(duracao[0])\n  if duracao == 1:\n    duracao = 60\n\n  escala = 60/duracao\n  passo = 1/escala\n\n  if escalaAutomatica:\n    distribuicao = [0]*24*int(escala) #Numero de bins caso a escala seja automatica\n\n    for valor in valores:\n      valor %= 24\n      valor *= escala\n      distribuicao[int((valor//1))] += 1 #Seleciona o bin especifico onde cabe aquele valor e adiciona +1\n      valor /= escala\n\n\n  else:\n    distribuicao = [0]*24 #Se n\u00e3o seria o mesmo que escala = 1\n\n    for valor in valores:\n      valor %= 24\n      distribuicao[int((valor//1))] += 1\n\n  eixo_y = max(distribuicao) + 1 #Distribui\u00e7\u00e3o faz o trabalho manual do histograma para descobrir o valor m\u00e1ximo em y\n\n  #Formata os major positions - inteiros e de 0 a 23 e os minor positions -- dependem da escala (0,5 0,25 ou 0,75)\n  #Essas ser\u00e3o as posi\u00e7\u00f5es que os horarios entar\u00e3o na tela\n  major_positions=list(range(0,24))\n  minor_positions=[]\n  cont =1\n  #Major_positions s\u00e3o as horas, passa por todas as horas e adiciona em minor_positions todas as divis\u00f5es necess\u00e1rias\n  for major_position in major_positions:\n      while cont < escala:\n        minor_positions.append(major_position+cont*passo)\n        cont+=1\n      cont=1\n\n  #Formata os ticks que aparecem na tela como horas\n  major_hora = []\n  minor_hora = []\n  cont = 1\n  i=0\n  while len(major_hora)<24:\n    major_hora.append(str(i)+':'+\"00\")\n    while cont<escala:\n      if cont*duracao == 30:\n        minor_hora.append(str(i)+\":30\")\n      else:\n        minor_hora.append('')\n      cont+=1\n    cont=1\n    i+=1\n\n  ##A partir daqui: Cria\u00e7\u00e3o e formata\u00e7\u00e3o do gr\u00e1fico\n  # plot:\n  fig, ax = plt.subplots(figsize=(14,5))\n\n  bins = []\n  cont = 0\n  #Cria as bins como uma lista com todas as divis\u00f5es\n  for i in range(0,24):\n    bins.append(i)\n    while cont < escala:\n        bins.append(bins[len(bins)-1]+(passo))\n        cont+=1\n    cont=1\n\n  ax.hist(valores, bins,width=passo, linewidth=0.5, edgecolor=\"white\", color = grafico1)#valores = valores a serem sorteados, bins = quais as divis\u00f5es\n\n  #formata os ticks\n  ax.tick_params(which='major', labelsize= 10, width=1.0, length=9)\n  ax.tick_params(which='minor', labelsize = 8,  width=0.75, length=2.5)\n\n  #Fixa a posi\u00e7\u00e3o dos ticks nos eixos\n  ax.xaxis.set_major_locator(ticker.FixedLocator(major_positions))\n  ax.xaxis.set_major_formatter(ticker.FixedFormatter(major_hora))\n\n  #Fixa o valor dos ticks no eixo\n  ax.xaxis.set_minor_locator(ticker.FixedLocator(minor_positions))\n  ax.xaxis.set_minor_formatter(ticker.FixedFormatter(minor_hora))\n\n  ax.set(xlim=(-0.5, 24.5*passo), xticks=np.arange(0, 24.5),\n        ylim=(0, eixo_y), yticks=np.arange(0, eixo_y))\n\n  plt.show()\n\n#Histograma comparativo\n#Aqui est\u00e1 todo o processamento para formatar e criar um gr\u00e1fico com dois histogramas lado a lado\ndef hist_horizontal_comparativo(valores, duracao1, duracao2, mesmaEscala):\n\n  #Defini\u00e7\u00f5es histograma esquerda\n\n  duracao1 = duracao1.split()\n  duracao1 = int(duracao1[0])\n  if duracao1 == 1:\n    duracao1 = 60\n\n  escala1 = 60/duracao1\n  passo = 1/escala1\n\n  #Cria as bins como uma lista com todas as divis\u00f5es\n  bins =[]\n  cont = 1\n  for i in range(0,25):\n    bins.append(i)\n    while cont < escala1:\n        bins.append(bins[len(bins)-1]+(passo))\n        cont+=1\n    cont=1\n\n  #Fim defini\u00e7\u00f5es histograma esquerda\n\n  #Defini\u00e7\u00f5es histograma direita\n  duracao2 = duracao2.split()\n  duracao2 = int(duracao2[0])\n  if duracao2 == 1:\n    duracao2 = 60\n\n  escala2 = 60/duracao2\n  passo = 1/escala2\n\n  bins2 =[]\n  cont = 1\n  for i in range(0,25):\n    bins2.append(i)\n    while cont < escala2:\n        bins2.append(bins2[len(bins2)-1]+(passo))\n        cont+=1\n    cont=1\n\n  #fim defini\u00e7\u00f5es histograma direita\n\n  escala = min(escala1,escala2)\n\n  #Escala autom\u00e1tica\n  if mesmaEscala:\n    #encaixa os valores de horarios em suas posi\u00e7\u00f5es dependendo do proprio horario\n    distribuicao = [0]*24*int(escala)\n\n    for valor in valores:\n      valor %= 24\n      valor *= escala\n      distribuicao[int((valor//1))] += 1\n      valor /= escala\n    distribuicao2 = distribuicao.copy()\n    distribuicao1 = distribuicao.copy()\n  else:\n    distribuicao1 = [0]*24*int(escala1)\n    distribuicao2 = [0]*24*int(escala2)\n    for valor in valores:\n      valor %= 24\n      valor *= escala1\n      distribuicao1[int((valor//1))] += 1\n      valor /= escala1\n      valor *= escala2\n      distribuicao2[int((valor//1))] += 1\n      valor /= escala2\n\n  eixo_x1 = max(distribuicao1) + 1\n  eixo_x2 = max(distribuicao2) + 1\n\n\n  #Igual para ambos\n  escala = max(escala1,escala2)\n  duracao = 60/escala\n  passo = 1/escala\n  #Formata os major positions - inteiros e de 0 a 23 e os minor positions -- dependem da escala (0,5 0,25 ou 0,75)\n  major_positions=list(range(0,25))\n  minor_positions=[]\n  cont = 1\n  for major_position in major_positions:\n      while cont < escala:\n        minor_positions.append(major_position+cont*passo)\n        cont+=1\n      cont=1\n\n  #Formata os ticks que aparecem na tela como horas\n  major_hora = []\n  minor_hora = []\n  cont = 1\n  i=0\n  while len(major_hora)<=24:\n    major_hora.append(str(i)+':'+\"00\")\n\n    if len(major_hora)<=24:\n      while cont<escala:\n        if cont*duracao == 30:\n          minor_hora.append(str(i)+\":30\")\n        else:\n          minor_hora.append('')\n        cont+=1\n    cont=1\n    i+=1\n  # plot:\n  #fig = plt.figure(figsize=(8,10), facecolor='lightblue')\n  #ax[0] = fig.add_axes([2,4,2,8])\n  #ax[1] = fig.add_axes([4,6,2,8])\n  fig, ax = plt.subplots(1,2,figsize=(8,10), sharey=True)\n\n  #Histograma esquerdo\n  #Cria o histograma na horizontal esquerdo\n  ax[0].hist(valores, bins, height=1/escala1,weights=-np.ones_like(valores), linewidth=0.5, edgecolor=\"white\", orientation = \"horizontal\", color = grafico2)#valores = valores a serem sorteados, bins = quais as divis\u00f5es\n  #Habilita o grid\n  ax[0].grid(visible = True, which = 'major', axis = 'y')\n\n  #formata os ticks\n  ax[0].tick_params(which='major', labelsize= 10, width=1.0, length=7)\n  ax[0].tick_params(which='minor', labelsize = 8,  width=0.75, length=2.5)\n\n  #Fixa a posi\u00e7\u00e3o dos ticks\n  ax[0].yaxis.set_major_locator(ticker.FixedLocator(major_positions))\n  ax[0].yaxis.set_major_formatter(ticker.FixedFormatter(major_hora))\n\n  #Define o texto dos ticks\n  ax[0].yaxis.set_minor_locator(ticker.FixedLocator(minor_positions))\n  ax[0].yaxis.set_minor_formatter(ticker.FixedFormatter(minor_hora))\n\n  #Arruma o eixo x - pois est\u00e1 negativo\n  ax[0].xaxis.set_major_locator(ticker.FixedLocator(range(-eixo_x1, 0)))\n\n  #Arruma para que todo eixo seja positivo\n  valor  = []\n  for i in range(-eixo_x1, 0):\n    valor.append(abs(i))\n\n  ax[0].xaxis.set_major_formatter(ticker.FixedFormatter(valor))\n\n  ax[0].set_xlim(-eixo_x1, 0)\n  ax[0].set_ylim(-0.5, 24.5)\n\n  #Cria o histograma na horizontal direito\n  ax[1].hist(valores, bins2, height=1/escala2, linewidth=0.5, edgecolor=\"white\", orientation = \"horizontal\", color = grafico1)\n  #Habilita o grid\n  ax[1].grid(visible = True, which = 'major', axis = 'y')\n\n  #formata os ticks\n  ax[1].tick_params(which='major', labelsize= 10, width=1.0, length=7)\n  ax[1].tick_params(which='minor', labelsize = 8,  width=0.75, length=2.5)\n\n  #Fixa a posi\u00e7\u00e3o dos ticks\n  ax[1].yaxis.set_major_locator(ticker.FixedLocator(major_positions))\n  ax[1].yaxis.set_major_formatter(ticker.FixedFormatter(major_hora))\n\n  #Define o texto dos ticks\n  ax[1].yaxis.set_minor_locator(ticker.FixedLocator(minor_positions))\n  ax[1].yaxis.set_minor_formatter(ticker.FixedFormatter(minor_hora))\n\n  #Define a posi\u00e7\u00e3o e valor do eixo x\n  ax[1].xaxis.set_major_locator(ticker.FixedLocator(range(0, eixo_x2+1)))\n  ax[1].xaxis.set_major_formatter(ticker.FixedFormatter(range(0, eixo_x2+1)))\n\n  ax[1].set_xlim(0,eixo_x2)\n  ax[1].set_ylim(-0.5, 24.5)\n\n  # Adjust spacing\n  plt.subplots_adjust(left=0.1, right=0.9,\n                      top=0.9, bottom=0.1,\n                      wspace=0.0) #A dist\u00e2ncia pra ficar s\u00f3 ticks entre eles \u00e9 0.035\n\n  plt.show()\n\n  #Cria e formata o menu de um gr\u00e1fico \u00fanico\ndef graficoUnico ():\n    #Menu com:\n    #Check p/ ajustar propor\u00e7\u00e3o\n    #Slider p/ dura\u00e7\u00e3o\n    #Caixa de texto p/ horarios\n    #Botao de atualizar\n    #Botao de voltar\n\n    #Check de ajustar propor\u00e7\u00e3o\n    check = widgets.Checkbox(value=False,\n                          description='Ajustar Propor\u00e7\u00e3o',\n                          disabled=False,\n                          indent=False\n                          )\n    #caixa de texto para hor\u00e1rios\n    text = widgets.Text(\n                        value='',\n                        placeholder='00:00 01:00 ...',\n                        description='',\n                        disabled=False\n                        )\n\n    #Duracao - slider para selecionar o intervalo\n    slider = widgets.SelectionSlider(options=['15 minutos','20 minutos', '30 minutos', '1 hora'],\n                                     value= '1 hora',\n                                     description='',\n                                     disabled=False,\n                                     continuous_update=False,\n                                     orientation='horizontal',\n                                     readout=True\n                                     )\n    #Botao de atualizar\n    button = widgets.Button(description=\"Enviar hor\u00e1rios\")\n    #botao de voltar\n    voltar = widgets.Button(description=\"Voltar\")\n    #Caixa para permitir a organiza\u00e7\u00e3o\n    caixa1 = widgets.Box(\n        [\n            widgets.Label(value='Insira os horarios de \u00f4nibus:'),\n            text,\n            button\n        ]\n    )\n    #caixa para permitir a organiza\u00e7\u00e3o\n    caixa2 = widgets.Box(\n        [\n            widgets.Label(value='Selecione o intervalo:'),\n            slider,\n        ]\n    )\n    out = widgets.Output(wait = True) #Cria um ambiente de exposi\u00e7\u00e3o\n    display (out)\n    with out:\n      display(caixa1, caixa2, check, voltar)\n\n    outGraf = widgets.Output()\n    display(outGraf)\n\n    def on_button_clicked(button): #Quando o bot\u00e3o de enviar for apertado, limpa a \u00e1rea do gr\u00e1fico e chama um novo grafico com os valores mais atualizados\n      outGraf.clear_output(wait = True)\n      with outGraf:\n        hist_vertical(valores=tratamento(novo = text.value), duracao = slider.value, escalaAutomatica = check.value)\n\n    def on_voltar_clicked(voltar): #Quando o bot\u00e3o de voltar for apertado, limpa toda a \u00e1rea e volta ao menu principal\n      out.clear_output()\n      outGraf.clear_output()\n      principal()\n\n    def valueChange(change): #Quando qualquer valor for alterado, limpa a area do gr\u00e1fico e cria um novo gr\u00e1fico com os valores atualizados\n      outGraf.clear_output(wait = True)\n      with outGraf:\n        hist_vertical(valores=tratamento(novo = text.value), duracao = slider.value, escalaAutomatica = check.value)\n\n    check.observe(valueChange, names= \"value\")\n    slider.observe(valueChange, names= \"value\")\n    voltar.on_click(on_voltar_clicked)\n    button.on_click(on_button_clicked)\n\n#Define e formata as op\u00e7\u00f5es de um gr\u00e1fico comparativo -- dois histogramas\ndef graficoComp ():\n    #Menu com:\n    #Escala fixa ou autom\u00e1tica\n    #2 Slider p/ dura\u00e7\u00e3o\n    #Caixa de texto p/ horarios\n    #Botao de atualizar\n    #Botao de voltar?\n\n    #escala\n    check = widgets.Checkbox(value=False,\n                          description='Mesma Propor\u00e7\u00e3o',\n                          disabled=False,\n                          indent=False\n                          )\n    #caixa de texto\n    text = widgets.Text(value='',\n                        placeholder='00:00 01:00 ...',\n                        description='',\n                        disabled=False\n                        )\n    #Dura\u00e7\u00e3o 1\n    slider1 = widgets.SelectionSlider(options=['15 minutos','20 minutos', '30 minutos', '1 hora'],\n                                     value= '1 hora',\n                                     description='',\n                                     disabled=False,\n                                     continuous_update=False,\n                                     orientation='horizontal',\n                                     readout=True\n                                     )\n    #Dura\u00e7\u00e3o 2\n    slider2 = widgets.SelectionSlider(options=['15 minutos','20 minutos', '30 minutos', '1 hora'],\n                                     value= '1 hora',\n                                     description='',\n                                     disabled=False,\n                                     continuous_update=False,\n                                     orientation='horizontal',\n                                     readout=True)\n    #Botao de atualizar\n    button = widgets.Button(description=\"Enviar hor\u00e1rios\")\n    #botao de voltar\n    voltar = widgets.Button(description=\"Voltar\")\n    caixa1 = widgets.Box(\n        [\n            widgets.Label(value='Insira os horarios de \u00f4nibus:'),\n            text,\n            button\n        ]\n    )\n    caixa2 = widgets.Box(\n        [\n            widgets.Label(value='Intervalo do gr\u00e1fico da esquerda:'),\n            slider1,\n            widgets.Label(value='   Intervalo do gr\u00e1fico da direita:'),\n            slider2,\n        ]\n    )\n    out = widgets.Output()\n    display (out)\n    with out:\n      display(caixa1, caixa2, check, voltar)\n\n    outGraf = widgets.Output()\n    display(outGraf)\n    def on_button_clicked(button):#Quando o bot\u00e3o de enviar for apertado, limpa a \u00e1rea do gr\u00e1fico e chama um novo grafico com os valores mais atualizados\n      outGraf.clear_output(wait = True)\n      with outGraf:\n        hist_horizontal_comparativo(valores = tratamento(novo = text.value), duracao1 = slider1.value, duracao2 = slider2.value, mesmaEscala=check.value)\n\n    def on_voltar_clicked(voltar): #Quando o bot\u00e3o de voltar for apertado, limpa toda a \u00e1rea e volta ao menu principal\n      out.clear_output()\n      outGraf.clear_output()\n      principal()\n\n    def valueChange(change): #Quando qualquer valor for alterado, limpa a area do gr\u00e1fico e cria um novo gr\u00e1fico com os valores atualizados\n      outGraf.clear_output(wait = True)\n      with outGraf:\n        hist_horizontal_comparativo(valores = tratamento(novo = text.value), duracao1 = slider1.value, duracao2 = slider2.value, mesmaEscala=check.value)\n\n    check.observe(valueChange, names= \"value\")\n    slider1.observe(valueChange, names= \"value\")\n    slider2.observe(valueChange, names= \"value\")\n    voltar.on_click(on_voltar_clicked)\n    button.on_click(on_button_clicked)\n\n\ndef delta_tempo(valores, intervalo):\n\n  #organiza\u00e7\u00e3o dos hor\u00e1rios por ordem crescente\n  valores.sort()\n  if len(valores) == 0:\n    valores = [0]\n  valores = [0]+valores+[24+valores[0]]#Adiciona 0 e 24 mais primeiro valor, pra funcinar nas bordas\n  #Cria\u00e7\u00e3o do gr\u00e1fico e do seu tamanho\n  fig, ax = plt.subplots(figsize=(18, 5))\n\n  axes1 = fig.add_subplot(111)\n  for i in range(0,len(valores)-1):\n    #Plot de cada subconjunto do gr\u00e1fico com o horario e o horario seguinte sendo o eixo x e o eixo y sendo o valor da diferen\u00e7a at\u00e9 0\n    axes1.plot ([valores[i], valores[i+1]],[(valores[i+1]-valores[i]), 0], color = grafico1)\n\n  duracao = 1\n  escala = 1\n  axes2 = plt.axes([.475, .45, .4, .4])\n\n  #axes1 \u00e9 o gr\u00e1fico maior\n  #axes2 \u00e9 o gr\u00e1fico menor\n\n  plt.setp(ax, xticks=[], yticks=[])\n  valores_intervalo = [intervalo[0]] #Lista com todos os valores de dentro do intervalo\n  for valor in valores:\n    if valor > intervalo[0] and valor < intervalo[1]:\n      valores_intervalo.append(valor)\n    elif valor >= intervalo[1]:\n      valores_intervalo.append(valor)\n      break\n\n  for i in range(0,len(valores)-1):\n    #Plot de cada subconjunto do gr\u00e1fico com o horario e o horario seguinte sendo o eixo x e o eixo y sendo o valor da diferen\u00e7a at\u00e9 0\n    axes2.plot ([valores[i], valores[i+1]],[(valores[i+1]-valores[i]), 0], color = grafico1)\n    #Plot de pontos na absissa de cada horario em que sai um onibus\n    axes2.plot (valores[i],0, marker = 'o', color = pontos)\n\n  media = sum([(valores_intervalo[i+1]-valores_intervalo[i])**2/2 for i in range(len(valores_intervalo)-1)]) #soma dos valores de dentro do intervalo\n  media -= (valores_intervalo[-1] - intervalo[1])**2/2 #Tirar o triangulo do final\n  media /= (intervalo[1]-intervalo[0]) #Dividido pela \u00e1rea\n\n\n  #Plot da linha de m\u00e9dia\n  axes2.plot((intervalo[0], intervalo[-1]), [media]*2, color = media_cor)\n\n  #Formata os ticks que aparecem na tela como horas\n  #Posi\u00e7\u00e3o das horas\n  major_positions=list(range(0,25))\n  cont =1\n  major_positions2 = list(range(0,25))\n  minor_positions2 = []\n  #Major_positions s\u00e3o as horas, passa por todas as horas e adiciona em minor_positions todas as divis\u00f5es necess\u00e1rias\n  for major_position in major_positions2:\n      while cont < 1:\n        minor_positions2.append(major_position+cont*0.5)\n        cont+=1\n      cont=1\n\n  #Valores que aparecem na tela\n  major_hora = []\n  minor_hora = []\n  i=0\n\n  while len(major_hora)<25:\n    major_hora.append(str(i)+':'+\"00\")\n    i+=1\n\n  #seta os ticks do gr\u00e1fico maior no formato\n  axes1.tick_params(which='major', labelsize= 10, width=1.0, length=9)\n  axes1.tick_params(which='minor', labelsize = 8,  width=0.75, length=2.5)\n\n  #Fixa a posi\u00e7\u00e3o dos ticks nos eixos do gr\u00e1fico maior\n  axes1.xaxis.set_major_locator(ticker.FixedLocator(major_positions))\n  axes1.xaxis.set_major_formatter(ticker.FixedFormatter(major_hora))\n\n  #formata os ticks do gr\u00e1fico menor\n  axes2.tick_params(which='major', labelsize= 10, width=1.0, length=9)\n  axes2.tick_params(which='minor', labelsize = 8,  width=0.75, length=2.5)\n\n  max_y = []\n  for i  in range(len(valores)-1):\n    if valores[i] >= intervalo[0] and valores[i] <= intervalo[-1]:\n      if len(max_y) == 0:\n        max_y.append(valores[i] - intervalo[0])\n      else:\n        max_y.append(valores[i+1]-valores[i])\n\n  i=0\n  while valores[i]<intervalo[-1]:\n    i += 1\n\n  if max_y == []:\n    max_y = [0,max(valores[i]-intervalo[0],media)]\n  axes2.set_ylim(0, max(max_y)+max(max_y)/10)\n  axes2.set_xlim(intervalo[0], intervalo[-1])\n\n  axes2.text((intervalo[-1] - ((intervalo[-1]-intervalo[0])/2)),(media + (max(max_y)/40)), \"Tempo m\u00e9dio de espera no intervalo selecionado\", color = palavras)\n\n  def float_para_hora(y, pos):\n    return f'{int(y):02d}:{int((y-int(y))*60):02d}'\n\n  axes2.yaxis.set_major_formatter(float_para_hora)\n  axes1.yaxis.set_major_formatter(float_para_hora)\n\n  axes2.xaxis.set_major_formatter(float_para_hora)\n\n  max_y = []\n  for i in range(0,len(valores)-1):\n    max_y.append(valores[i+1]-valores[i])\n  if max_y == []:\n    max_y = [0,24]\n  axes1.set_ylim(0,max(max_y)+max(max_y)/10)\n  axes1.set_xlim(0, 24.5)\n\n  #Indicadores s\u00e3o as linhas que ligam o gr\u00e1fico menor e a maior\n  indicadores =  axes1.indicate_inset_zoom(inset_ax = axes2, edgecolor='black')\n\n  indicadores.connectors[0].set_visible(True)\n  indicadores.connectors[1].set_visible(False)\n  indicadores.connectors[2].set_visible(True)\n  indicadores.connectors[3].set_visible(False)\n\n  plt.show()\n\n#Cria e formata o menu de um gr\u00e1fico \u00fanico\ndef graficoDelta ():\n    #Menu com:\n    #Slider p/ dura\u00e7\u00e3o\n    #Caixa de texto p/ horarios\n    #Botao de atualizar\n    #Botao de voltar\n\n    #caixa de texto\n    text = widgets.Text(\n                        value='',\n                        placeholder='00:00 01:00 ...',\n                        description='',\n                        disabled=False\n                        )\n\n    #Duracao\n    slider = widgets.FloatRangeSlider(\n                                      value=[0,24],\n                                      min=0,\n                                      max=24.0,\n                                      step=0.25,\n                                      description='',\n                                      disabled=False,\n                                      continuous_update=False,\n                                      orientation='horizontal',\n                                      readout=False,\n                                     )\n\n    #Botao de atualizar\n    button = widgets.Button(description=\"Enviar hor\u00e1rios\")\n    #botao de voltar\n    voltar = widgets.Button(description=\"Voltar\")\n    def float_para_hora(y):\n      return f'{int(y):02d}:{int((y-int(y))*60):02d}'\n    def caixa2():\n      hora_inicio = widgets.Label(value= float_para_hora(slider.value[0]))\n      hora_fim = widgets.Label(value= float_para_hora(slider.value[1]))\n      caixa2 = widgets.Box(  #Caixa 2 com o slider\n        [\n            widgets.Label(value='Selecione o intervalo:'),\n            slider,\n            hora_inicio,\n            hora_fim\n        ]\n      )\n      return caixa2\n    #Caixas organizam os widgets na tela\n    caixa1 = widgets.Box( #Caixa 1 com a caixa de texto e o botao\n        [\n            widgets.Label(value='Insira os horarios de \u00f4nibus:'),\n            text,\n            button\n        ]\n    )\n    caixa3 = widgets.Box(  #Caixa 3 com o botao de voltar\n        [\n            voltar\n        ]\n    )\n    out = widgets.Output(wait = True)\n    display (out)\n    with out:\n      display(caixa1)\n\n    outGraf = widgets.Output()\n    display(outGraf)\n    with outGraf:\n      display(caixa2(),caixa3)\n\n    def on_button_clicked(button): #Quando o bot\u00e3o de enviar for apertado, limpa a \u00e1rea do gr\u00e1fico e chama um novo grafico com os valores mais atualizados\n      outGraf.clear_output(wait = True)\n      if text.value == '':\n        outGraf.clear_output(wait = True)\n        with outGraf:\n          display(caixa2(),caixa3)\n          display('Este \u00e9 o gr\u00e1fico de espera sem nenhum hor\u00e1rio de \u00f4nibus')\n      else:\n        outGraf.clear_output(wait = True)\n        with outGraf:\n          display(caixa2(),caixa3)\n      with outGraf:\n        delta_tempo(valores=tratamento(novo = text.value), intervalo = slider.value)\n\n    def on_voltar_clicked(voltar): #Quando o bot\u00e3o de voltar for apertado, limpa toda a \u00e1rea e volta ao menu principal\n      out.clear_output()\n      outGraf.clear_output()\n      principal()\n\n    def valueChange(change): #Quando qualquer valor for alterado, limpa a area do gr\u00e1fico e cria um novo gr\u00e1fico com os valores atualizados\n      outGraf.clear_output(wait = True)\n\n      validador = True\n      if slider.value[0] == slider.value[1]:\n        validador = False\n        slider.value = [0,24]\n        outGraf.clear_output(wait = True)\n        with outGraf:\n          display(caixa2(),caixa3)\n          display('Os valores de m\u00e1ximo e de m\u00ednimo n\u00e3o podem ser iguais')\n\n      if text.value == '':\n        outGraf.clear_output(wait = True)\n        with outGraf:\n          display(caixa2(),caixa3)\n          display('Este \u00e9 o gr\u00e1fico de espera sem nenhum hor\u00e1rio de \u00f4nibus')\n      else:\n        if validador:\n          outGraf.clear_output(wait = True)\n          with outGraf:\n            display(caixa2(),caixa3)\n\n      with outGraf:\n        delta_tempo(valores=tratamento(novo = text.value), intervalo = slider.value)\n\n    slider.observe(valueChange, names= \"value\")\n    voltar.on_click(on_voltar_clicked)\n    button.on_click(on_button_clicked)\n\n#Cria e formata o menu principal\nchoice = widgets.Dropdown(options=[('Selecione...', 1), ('Gr\u00e1fico \u00fanico', 2), ('Gr\u00e1fico Comparativo', 3), ('Gr\u00e1fico de Tempo de Espera', 4) ],\n                        value= 1,\n                        description='',\n                        )\nout = widgets.Output()\ndisplay(out)\ncaixa = widgets.Box(\n    [\n        widgets.Label(value='Selecione o tipo de gr\u00e1fico:'),\n        choice\n    ]\n)\nwith out:\ndisplay(caixa)\n\ndef valueChangeChoice(change): #Quando o valor do menu mudar chama a fun\u00e7\u00e3o\nwith out:\n    if change['new'] == 2: #Se for gr\u00e1fico \u00fanico, chama o menu de gr\u00e1fico \u00fanico\n    out.clear_output(wait = True)\n    graficoUnico()\n    elif change['new'] == 3: #Se for gr\u00e1fico comparativo, chama o menu de gr\u00e1fico comparativo\n    out.clear_output(wait = True)\n    graficoComp()\n    elif change['new'] == 4: #Se for gr\u00e1fico de tempo de espera, chama o menu de tempo de espera\n    out.clear_output(wait = True)\n    graficoDelta()\n\nchoice.observe(valueChangeChoice, names='value')", "type": "text"}, {"name": "imagens/Cienvolva.jpeg", "content": "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", "type": "binary"}, {"name": "imagens/home_icon.png.png", "content": "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", "type": "binary"}]