[{"name": "app.py", "content": "import matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.ticker as ticker\n\nfrom functools import partial\nfrom shiny.ui import page_navbar\nfrom shiny.express import render, ui, input\nfrom shiny import reactive\n\nfrom matplotlib import cbook\n#Variaveis de design\npontos = '#0023FF'\npalavras = '#FFC400'\nmedia_cor = '#FFC400'\ngrafico1 = '#0023FF'\ngrafico2 = '#FFC400'\n\nui.page_opts(\n    title= \"Cienvolva\",  \n    #page_fn=partial(page_navbar, id=\"page\"),  \n    fillable=True\n)\n\ndef tratamento (novo): #Tratamento dos dados de horarios\n  horarios = []\n\n  for i in range(0, len(novo)): #Para qualquer separador, usa apenas os : para se basear\n    if novo[i] == ':':\n      horarios.append(novo[i-2:i+3])\n\n  for i in range(0,len(horarios)): #Para corrigir horarios como 4:15 para 04:15\n    if horarios[i][0] == ' ':\n      horarios[i] = '0'+horarios[i].strip()\n\n  #Transforma os horarios no formato de decimais\n  valores  = []\n\n  for horario in horarios:\n      hora, min = horario.split(\":\")\n      min = int(min)/60\n      valores.append (int(hora) + min)\n\n  for i in range(len(valores)): #Elimina valores como 24:15\n      valores[i] %= 24\n\n  if valores == []:\n    valores = [0]\n  return valores\n\ndef hist_vertical(valores, duracao, escalaAutomatica):\n  #Seleciona o tamanho de intevalos como um int\n  '''duracao = duracao.split()\n  duracao = int(duracao[0])\n  if duracao == 1:\n    duracao = 60'''\n\n  escala = 60/duracao\n  passo = 1/escala\n\n  if escalaAutomatica:\n    distribuicao = [0]*24*int(escala) #Numero de bins caso a escala seja automatica\n\n    for valor in valores:\n      valor %= 24\n      valor *= escala\n      distribuicao[int((valor//1))] += 1 #Seleciona o bin especifico onde cabe aquele valor e adiciona +1\n      valor /= escala\n\n\n  else:\n    distribuicao = [0]*24 #Se n\u00e3o seria o mesmo que escala = 1\n\n    for valor in valores:\n      valor %= 24\n      distribuicao[int((valor//1))] += 1\n\n  eixo_y = max(distribuicao) + 1 #Distribui\u00e7\u00e3o faz o trabalho manual do histograma para descobrir o valor m\u00e1ximo em y\n\n  #Formata os major positions - inteiros e de 0 a 23 e os minor positions -- dependem da escala (0,5 0,25 ou 0,75)\n  #Essas ser\u00e3o as posi\u00e7\u00f5es que os horarios entar\u00e3o na tela\n  major_positions=list(range(0,24))\n  minor_positions=[]\n  cont =1\n  #Major_positions s\u00e3o as horas, passa por todas as horas e adiciona em minor_positions todas as divis\u00f5es necess\u00e1rias\n  for major_position in major_positions:\n      while cont < escala:\n        minor_positions.append(major_position+cont*passo)\n        cont+=1\n      cont=1\n\n  #Formata os ticks que aparecem na tela como horas\n  major_hora = []\n  minor_hora = []\n  cont = 1\n  i=0\n  while len(major_hora)<24:\n    major_hora.append(str(i)+':'+\"00\")\n    while cont<escala:\n      if cont*duracao == 30:\n        minor_hora.append(str(i)+\":30\")\n      else:\n        minor_hora.append('')\n      cont+=1\n    cont=1\n    i+=1\n\n  ##A partir daqui: Cria\u00e7\u00e3o e formata\u00e7\u00e3o do gr\u00e1fico\n  # plot:\n  fig, ax = plt.subplots(figsize=(14,5))\n\n  bins = []\n  cont = 0\n  #Cria as bins como uma lista com todas as divis\u00f5es\n  for i in range(0,24):\n    bins.append(i)\n    while cont < escala:\n        bins.append(bins[len(bins)-1]+(passo))\n        cont+=1\n    cont=1\n\n  ax.hist(valores, bins,width=passo, linewidth=0.5, edgecolor=\"white\", color = grafico1)#valores = valores a serem sorteados, bins = quais as divis\u00f5es\n\n  #formata os ticks\n  ax.tick_params(which='major', labelsize= 10, width=1.0, length=9)\n  ax.tick_params(which='minor', labelsize = 8,  width=0.75, length=2.5)\n\n  #Fixa a posi\u00e7\u00e3o dos ticks nos eixos\n  ax.xaxis.set_major_locator(ticker.FixedLocator(major_positions))\n  ax.xaxis.set_major_formatter(ticker.FixedFormatter(major_hora))\n\n  #Fixa o valor dos ticks no eixo\n  ax.xaxis.set_minor_locator(ticker.FixedLocator(minor_positions))\n  ax.xaxis.set_minor_formatter(ticker.FixedFormatter(minor_hora))\n\n  ax.set(xlim=(-0.5, 24.5*passo), xticks=np.arange(0, 24.5),\n        ylim=(0, eixo_y), yticks=np.arange(0, eixo_y))\n\n  plt.show()\n\nwith ui.nav_panel(\"Gr\u00e1fico \u00danico\"):  \n    #Sidebar com menu de um gr\u00e1fico \u00fanico, cria\u00e7\u00e3o no gr\u00e1fico no main tab\n    with ui.layout_columns(col_widths=(3,9)):\n        with ui.card():  \n            #\"Aqui ficar\u00e1 o menu do gr\u00e1fico \u00danico\"\n            #Caixa de texto p/ horarios\n            ui.input_text_area(\"text\", \"Insira os hor\u00e1rios\", placeholder= \"00:00 01:00 01:15...\") \n            #Slider p/ dura\u00e7\u00e3o\n            ui.input_slider(\"slider\", \"Selecione o Intervalo\", min = 15, max = 60, value = 60, step = 15, post = \" minutos\")\n            #Check p/ ajustar propor\u00e7\u00e3o\n            ui.input_checkbox(\"check\", \"Ajustar propor\u00e7\u00e3o\", value = False)\n            #Bot\u00e3o de atualizar gr\u00e1fico\n            #ui.input_action_button(\"button\", \"Enviar Hor\u00e1rios\")\n        with ui.card():\n            #\"Aqui ficar\u00e1 o gr\u00e1fico \u00danico\"\n            @render.plot()\n            #@reactive.event(input.button)\n            def graf():\n                if input.text() == \"\":\n                   return\n                else:\n                    return hist_vertical(valores=tratamento(novo = input.text()), duracao = input.slider(), escalaAutomatica = input.check())\n                \n#Histograma comparativo\n#Aqui est\u00e1 todo o processamento para formatar e criar um gr\u00e1fico com dois histogramas lado a lado\ndef hist_horizontal_comparativo(valores, duracao1, duracao2, mesmaEscala):\n\n  #Defini\u00e7\u00f5es histograma esquerda\n\n  #duracao1 = duracao1.split()\n  #duracao1 = int(duracao1[0])\n  #if duracao1 == 1:\n  # duracao1 = 60\n\n  escala1 = 60/duracao1\n  passo = 1/escala1\n\n  #Cria as bins como uma lista com todas as divis\u00f5es\n  bins =[]\n  cont = 1\n  for i in range(0,25):\n    bins.append(i)\n    while cont < escala1:\n        bins.append(bins[len(bins)-1]+(passo))\n        cont+=1\n    cont=1\n\n  #Fim defini\u00e7\u00f5es histograma esquerda\n\n  #Defini\u00e7\u00f5es histograma direita\n  #duracao2 = duracao2.split()\n  #duracao2 = int(duracao2[0])\n  #if duracao2 == 1:\n  #  duracao2 = 60\n\n  escala2 = 60/duracao2\n  passo = 1/escala2\n\n  bins2 =[]\n  cont = 1\n  for i in range(0,25):\n    bins2.append(i)\n    while cont < escala2:\n        bins2.append(bins2[len(bins2)-1]+(passo))\n        cont+=1\n    cont=1\n\n  #fim defini\u00e7\u00f5es histograma direita\n\n  escala = min(escala1,escala2)\n\n  #Escala autom\u00e1tica\n  if mesmaEscala:\n    #encaixa os valores de horarios em suas posi\u00e7\u00f5es dependendo do proprio horario\n    distribuicao = [0]*24*int(escala)\n\n    for valor in valores:\n      valor %= 24\n      valor *= escala\n      distribuicao[int((valor//1))] += 1\n      valor /= escala\n    distribuicao2 = distribuicao.copy()\n    distribuicao1 = distribuicao.copy()\n  else:\n    distribuicao1 = [0]*24*int(escala1)\n    distribuicao2 = [0]*24*int(escala2)\n    for valor in valores:\n      valor %= 24\n      valor *= escala1\n      distribuicao1[int((valor//1))] += 1\n      valor /= escala1\n      valor *= escala2\n      distribuicao2[int((valor//1))] += 1\n      valor /= escala2\n\n  eixo_x1 = max(distribuicao1) + 1\n  eixo_x2 = max(distribuicao2) + 1\n\n\n  #Igual para ambos\n  escala = max(escala1,escala2)\n  duracao = 60/escala\n  passo = 1/escala\n  #Formata os major positions - inteiros e de 0 a 23 e os minor positions -- dependem da escala (0,5 0,25 ou 0,75)\n  major_positions=list(range(0,25))\n  minor_positions=[]\n  cont = 1\n  for major_position in major_positions:\n      while cont < escala:\n        minor_positions.append(major_position+cont*passo)\n        cont+=1\n      cont=1\n\n  #Formata os ticks que aparecem na tela como horas\n  major_hora = []\n  minor_hora = []\n  cont = 1\n  i=0\n  while len(major_hora)<=24:\n    major_hora.append(str(i)+':'+\"00\")\n\n    if len(major_hora)<=24:\n      while cont<escala:\n        if cont*duracao == 30:\n          minor_hora.append(str(i)+\":30\")\n        else:\n          minor_hora.append('')\n        cont+=1\n    cont=1\n    i+=1\n  # plot:\n  #fig = plt.figure(figsize=(8,10), facecolor='lightblue')\n  #ax[0] = fig.add_axes([2,4,2,8])\n  #ax[1] = fig.add_axes([4,6,2,8])\n  fig, ax = plt.subplots(1,2,figsize=(8,10), sharey=True)\n\n  #Histograma esquerdo\n  #Cria o histograma na horizontal esquerdo\n  ax[0].hist(valores, bins, height=1/escala1,weights=-np.ones_like(valores), linewidth=0.5, edgecolor=\"white\", orientation = \"horizontal\", color = grafico2)#valores = valores a serem sorteados, bins = quais as divis\u00f5es\n  #Habilita o grid\n  ax[0].grid(visible = True, which = 'major', axis = 'y')\n\n  #formata os ticks\n  ax[0].tick_params(which='major', labelsize= 10, width=1.0, length=7)\n  ax[0].tick_params(which='minor', labelsize = 8,  width=0.75, length=2.5)\n\n  #Fixa a posi\u00e7\u00e3o dos ticks\n  ax[0].yaxis.set_major_locator(ticker.FixedLocator(major_positions))\n  ax[0].yaxis.set_major_formatter(ticker.FixedFormatter(major_hora))\n\n  #Define o texto dos ticks\n  ax[0].yaxis.set_minor_locator(ticker.FixedLocator(minor_positions))\n  ax[0].yaxis.set_minor_formatter(ticker.FixedFormatter(minor_hora))\n\n  #Arruma o eixo x - pois est\u00e1 negativo\n  ax[0].xaxis.set_major_locator(ticker.FixedLocator(range(-eixo_x1, 0)))\n\n  #Arruma para que todo eixo seja positivo\n  valor  = []\n  for i in range(-eixo_x1, 0):\n    valor.append(abs(i))\n\n  ax[0].xaxis.set_major_formatter(ticker.FixedFormatter(valor))\n\n  ax[0].set_xlim(-eixo_x1, 0)\n  ax[0].set_ylim(-0.5, 24.5)\n\n  #Cria o histograma na horizontal direito\n  ax[1].hist(valores, bins2, height=1/escala2, linewidth=0.5, edgecolor=\"white\", orientation = \"horizontal\", color = grafico1)\n  #Habilita o grid\n  ax[1].grid(visible = True, which = 'major', axis = 'y')\n\n  #formata os ticks\n  ax[1].tick_params(which='major', labelsize= 10, width=1.0, length=7)\n  ax[1].tick_params(which='minor', labelsize = 8,  width=0.75, length=2.5)\n\n  #Fixa a posi\u00e7\u00e3o dos ticks\n  ax[1].yaxis.set_major_locator(ticker.FixedLocator(major_positions))\n  ax[1].yaxis.set_major_formatter(ticker.FixedFormatter(major_hora))\n\n  #Define o texto dos ticks\n  ax[1].yaxis.set_minor_locator(ticker.FixedLocator(minor_positions))\n  ax[1].yaxis.set_minor_formatter(ticker.FixedFormatter(minor_hora))\n\n  #Define a posi\u00e7\u00e3o e valor do eixo x\n  ax[1].xaxis.set_major_locator(ticker.FixedLocator(range(0, eixo_x2+1)))\n  ax[1].xaxis.set_major_formatter(ticker.FixedFormatter(range(0, eixo_x2+1)))\n\n  ax[1].set_xlim(0,eixo_x2)\n  ax[1].set_ylim(-0.5, 24.5)\n\n  # Adjust spacing\n  plt.subplots_adjust(left=0.1, right=0.9,\n                      top=0.9, bottom=0.1,\n                      wspace=0.0) #A dist\u00e2ncia pra ficar s\u00f3 ticks entre eles \u00e9 0.035\n\n  plt.show()                \n\nwith ui.nav_panel(\"Gr\u00e1fico Comparativo\"):  \n    #Sidebar com menu de um gr\u00e1fico comparativo, cria\u00e7\u00e3o no gr\u00e1fico no main tab\n    with ui.layout_columns(col_widths=(3,9), row_heights= (12), fill = True):\n        with ui.card():  \n            #\"Aqui ficar\u00e1 o menu do gr\u00e1fico comparativo\" \n            #Caixa de texto p/ horarios\n            ui.input_text_area(\"text1\", \"Insira os hor\u00e1rios\", placeholder= \"00:00 01:00 01:15...\") \n            #Slider p/ dura\u00e7\u00e3o\n            ui.input_slider(\"slider1\", \"Intervalo do gr\u00e1fico da direita: \", min = 15, max = 60, value = 60, step = 15, post = \" minutos\")\n            #Slider p/dura\u00e7\u00e3o 2\n            ui.input_slider(\"slider2\", \"Intervalo do gr\u00e1fico da esquerda: \", min = 15, max = 60, value = 60, step = 15, post = \" minutos\")\n            #Check p/ ajustar propor\u00e7\u00e3o\n            ui.input_checkbox(\"check1\", \"Ajustar propor\u00e7\u00e3o\", value = False)\n        with ui.card():\n            #\"Aqui ficar\u00e1 o gr\u00e1fico comparativo\"\n            @render.plot()\n            #@reactive.event(input.button)\n            def graf1():\n                if input.text1() == \"\":\n                   return\n                else:\n                    return hist_horizontal_comparativo(valores=tratamento(novo = input.text1()), duracao1 = input.slider1(), duracao2 = input.slider2(), mesmaEscala = input.check1())\n\ndef delta_tempo(valores, intervalo):\n\n  #organiza\u00e7\u00e3o dos hor\u00e1rios por ordem crescente\n  valores.sort()\n  if len(valores) == 0:\n    valores = [0]\n  valores = [0]+valores+[24+valores[0]]#Adiciona 0 e 24 mais primeiro valor, pra funcinar nas bordas\n  #Cria\u00e7\u00e3o do gr\u00e1fico e do seu tamanho\n  fig, axes1 = plt.subplots(figsize=(30, 7))\n\n  for i in range(0,len(valores)-1):\n    #Plot de cada subconjunto do gr\u00e1fico com o horario e o horario seguinte sendo o eixo x e o eixo y sendo o valor da diferen\u00e7a at\u00e9 0\n    axes1.plot ([valores[i], valores[i+1]],[(valores[i+1]-valores[i]), 0], color = grafico1)\n\n  duracao = 1\n  escala = 1\n\n  axes2 = axes1.inset_axes(bounds = [.575, .55, .4, .4],zorder=6)\n  #axes1 \u00e9 o gr\u00e1fico maior\n  #axes2 \u00e9 o gr\u00e1fico menor\n\n  #plt.setp(ax, xticks=[], yticks=[])\n  valores_intervalo = [intervalo[0]] #Lista com todos os valores de dentro do intervalo\n  for valor in valores:\n    if valor > intervalo[0] and valor < intervalo[1]:\n      valores_intervalo.append(valor)\n    elif valor >= intervalo[1]:\n      valores_intervalo.append(valor)\n      break\n\n  for i in range(0,len(valores)-1):\n    #Plot de cada subconjunto do gr\u00e1fico com o horario e o horario seguinte sendo o eixo x e o eixo y sendo o valor da diferen\u00e7a at\u00e9 0\n    axes2.plot ([valores[i], valores[i+1]],[(valores[i+1]-valores[i]), 0], color = grafico1)\n    #Plot de pontos na absissa de cada horario em que sai um onibus\n    axes2.plot (valores[i],0, marker = 'o', color = pontos)\n\n  media = sum([(valores_intervalo[i+1]-valores_intervalo[i])**2/2 for i in range(len(valores_intervalo)-1)]) #soma dos valores de dentro do intervalo\n  media -= (valores_intervalo[-1] - intervalo[1])**2/2 #Tirar o triangulo do final\n  media /= (intervalo[1]-intervalo[0]) #Dividido pela \u00e1rea\n\n\n  #Plot da linha de m\u00e9dia\n  axes2.plot((intervalo[0], intervalo[-1]), [media]*2, color = media_cor)\n\n  #Formata os ticks que aparecem na tela como horas\n  #Posi\u00e7\u00e3o das horas\n  major_positions=list(range(0,25))\n  cont =1\n  major_positions2 = list(range(0,25))\n  minor_positions2 = []\n  #Major_positions s\u00e3o as horas, passa por todas as horas e adiciona em minor_positions todas as divis\u00f5es necess\u00e1rias\n  for major_position in major_positions2:\n      while cont < 1:\n        minor_positions2.append(major_position+cont*0.5)\n        cont+=1\n      cont=1\n\n  #Valores que aparecem na tela\n  major_hora = []\n  minor_hora = []\n  i=0\n\n  while len(major_hora)<25:\n    major_hora.append(str(i)+':'+\"00\")\n    i+=1\n\n  #seta os ticks do gr\u00e1fico maior no formato\n  axes1.tick_params(which='major', labelsize= 10, width=1.0, length=9)\n  axes1.tick_params(which='minor', labelsize = 8,  width=0.75, length=2.5)\n\n  #Fixa a posi\u00e7\u00e3o dos ticks nos eixos do gr\u00e1fico maior\n  axes1.xaxis.set_major_locator(ticker.FixedLocator(major_positions))\n  axes1.xaxis.set_major_formatter(ticker.FixedFormatter(major_hora))\n\n  #formata os ticks do gr\u00e1fico menor\n  axes2.tick_params(which='major', labelsize= 10, width=1.0, length=9)\n  axes2.tick_params(which='minor', labelsize = 8,  width=0.75, length=2.5)\n\n  max_y = []\n  for i  in range(len(valores)-1):\n    if valores[i] >= intervalo[0] and valores[i] <= intervalo[-1]:\n      if len(max_y) == 0:\n        max_y.append(valores[i] - intervalo[0])\n      else:\n        max_y.append(valores[i+1]-valores[i])\n\n  i=0\n  while valores[i]<intervalo[-1]:\n    i += 1\n\n  if max_y == []:\n    max_y = [0,max(valores[i]-intervalo[0],media)]\n  axes2.set_ylim(0, max(max_y)+max(max_y)/10)\n  axes2.set_xlim(intervalo[0], intervalo[-1])\n\n  axes2.text(intervalo[0],(media + (max(max_y)/40)), \" Tempo m\u00e9dio de espera no intervalo selecionado\", color = palavras)\n\n  def float_para_hora(y, pos):\n    return f'{int(y):02d}:{int((y-int(y))*60):02d}'\n\n  axes2.yaxis.set_major_formatter(float_para_hora)\n  axes1.yaxis.set_major_formatter(float_para_hora)\n\n  axes2.xaxis.set_major_formatter(float_para_hora)\n\n  max_y = []\n  for i in range(0,len(valores)-1):\n    max_y.append(valores[i+1]-valores[i])\n  if max_y == []:\n    max_y = [0,24]\n  axes1.set_ylim(0,max(max_y)+max(max_y)/10)\n  axes1.set_xlim(0, 24.5)\n\n  #Indicadores s\u00e3o as linhas que ligam o gr\u00e1fico menor e a maior\n  indicadores =  axes1.indicate_inset_zoom(inset_ax = axes2, edgecolor='black')\n\n  plt.show()\n\n\nwith ui.nav_panel(\"Gr\u00e1fico de tempo de espera\"):  \n    #Sidebar com menu de um gr\u00e1fico de tempo de espera, cria\u00e7\u00e3o no gr\u00e1fico no main tab\n    with ui.layout_columns(col_widths=(3,9)):\n        with ui.card(): \n            #\"Aqui ficar\u00e1 o menu do gr\u00e1fico de tempo de espera\"  \n            ui.input_text_area(\"text2\", \"Insira os hor\u00e1rios: \", placeholder = \"00:00 01:00 02:00 ...\")\n            ui.input_slider(\"range\", \"Intervalo\", min=0, max= 24, value = [00, 24], step = 0.25)\n        with ui.card():\n            #\"Aqui ficar\u00e1 o gr\u00e1fico de tempo de espera\"\n            @render.plot()\n            #@reactive.event(input.button)\n            def graf2():\n                if input.text2() == \"\":\n                  return\n                else:\n                  return delta_tempo(valores = tratamento(input.text2()), intervalo = input.range())", "type": "text"}, {"name": "Onibus.py", "content": "# @title C\u00f3digo\n# @markdown Pressione o bot\u00e3o \u00b4Play\u00b4 ao lado para executar o aplicativo\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport matplotlib.ticker as ticker\nfrom ipywidgets import interact, interactive, fixed, interact_manual\nimport ipywidgets as widgets\n\n\n#Variaveis de design\npontos = '#0023FF'\npalavras = '#FFC400'\nmedia_cor = '#FFC400'\ngrafico1 = '#0023FF'\ngrafico2 = '#FFC400'\n\n#Tratamento do input de horarios\n## -- Recebe e formata os valores -- recebe horarios e retorna os valores em decimais\n#Salva input de horarios em uma lista\ndef tratamento (novo):\n  horarios = []\n\n  for i in range(0, len(novo)): #Para qualquer separador, usa apenas os : para se basear\n    if novo[i] == ':':\n      horarios.append(novo[i-2:i+3])\n\n  for i in range(0,len(horarios)): #Para corrigir horarios como 4:15 para 04:15\n    if horarios[i][0] == ' ':\n      horarios[i] = '0'+horarios[i].strip()\n\n  #Transforma os horarios no formato de decimais\n  valores  = []\n\n  for horario in horarios:\n      hora, min = horario.split(\":\")\n      min = int(min)/60\n      valores.append (int(hora) + min)\n\n  for i in range(len(valores)): #Elimina valores como 24:15\n      valores[i] %= 24\n\n  if valores == []:\n    valores = [0]\n  return valores\n#Histograma vertical\n#Aqui cont\u00e9m todo processamento necess\u00e1rio para criar e formatar um histograma \u00fanico\n\ndef hist_vertical(valores, duracao, escalaAutomatica):\n  #Seleciona o tamanho de intevalos como um int\n  duracao = duracao.split()\n  duracao = int(duracao[0])\n  if duracao == 1:\n    duracao = 60\n\n  escala = 60/duracao\n  passo = 1/escala\n\n  if escalaAutomatica:\n    distribuicao = [0]*24*int(escala) #Numero de bins caso a escala seja automatica\n\n    for valor in valores:\n      valor %= 24\n      valor *= escala\n      distribuicao[int((valor//1))] += 1 #Seleciona o bin especifico onde cabe aquele valor e adiciona +1\n      valor /= escala\n\n\n  else:\n    distribuicao = [0]*24 #Se n\u00e3o seria o mesmo que escala = 1\n\n    for valor in valores:\n      valor %= 24\n      distribuicao[int((valor//1))] += 1\n\n  eixo_y = max(distribuicao) + 1 #Distribui\u00e7\u00e3o faz o trabalho manual do histograma para descobrir o valor m\u00e1ximo em y\n\n  #Formata os major positions - inteiros e de 0 a 23 e os minor positions -- dependem da escala (0,5 0,25 ou 0,75)\n  #Essas ser\u00e3o as posi\u00e7\u00f5es que os horarios entar\u00e3o na tela\n  major_positions=list(range(0,24))\n  minor_positions=[]\n  cont =1\n  #Major_positions s\u00e3o as horas, passa por todas as horas e adiciona em minor_positions todas as divis\u00f5es necess\u00e1rias\n  for major_position in major_positions:\n      while cont < escala:\n        minor_positions.append(major_position+cont*passo)\n        cont+=1\n      cont=1\n\n  #Formata os ticks que aparecem na tela como horas\n  major_hora = []\n  minor_hora = []\n  cont = 1\n  i=0\n  while len(major_hora)<24:\n    major_hora.append(str(i)+':'+\"00\")\n    while cont<escala:\n      if cont*duracao == 30:\n        minor_hora.append(str(i)+\":30\")\n      else:\n        minor_hora.append('')\n      cont+=1\n    cont=1\n    i+=1\n\n  ##A partir daqui: Cria\u00e7\u00e3o e formata\u00e7\u00e3o do gr\u00e1fico\n  # plot:\n  fig, ax = plt.subplots(figsize=(14,5))\n\n  bins = []\n  cont = 0\n  #Cria as bins como uma lista com todas as divis\u00f5es\n  for i in range(0,24):\n    bins.append(i)\n    while cont < escala:\n        bins.append(bins[len(bins)-1]+(passo))\n        cont+=1\n    cont=1\n\n  ax.hist(valores, bins,width=passo, linewidth=0.5, edgecolor=\"white\", color = grafico1)#valores = valores a serem sorteados, bins = quais as divis\u00f5es\n\n  #formata os ticks\n  ax.tick_params(which='major', labelsize= 10, width=1.0, length=9)\n  ax.tick_params(which='minor', labelsize = 8,  width=0.75, length=2.5)\n\n  #Fixa a posi\u00e7\u00e3o dos ticks nos eixos\n  ax.xaxis.set_major_locator(ticker.FixedLocator(major_positions))\n  ax.xaxis.set_major_formatter(ticker.FixedFormatter(major_hora))\n\n  #Fixa o valor dos ticks no eixo\n  ax.xaxis.set_minor_locator(ticker.FixedLocator(minor_positions))\n  ax.xaxis.set_minor_formatter(ticker.FixedFormatter(minor_hora))\n\n  ax.set(xlim=(-0.5, 24.5*passo), xticks=np.arange(0, 24.5),\n        ylim=(0, eixo_y), yticks=np.arange(0, eixo_y))\n\n  plt.show()\n\n#Histograma comparativo\n#Aqui est\u00e1 todo o processamento para formatar e criar um gr\u00e1fico com dois histogramas lado a lado\ndef hist_horizontal_comparativo(valores, duracao1, duracao2, mesmaEscala):\n\n  #Defini\u00e7\u00f5es histograma esquerda\n\n  duracao1 = duracao1.split()\n  duracao1 = int(duracao1[0])\n  if duracao1 == 1:\n    duracao1 = 60\n\n  escala1 = 60/duracao1\n  passo = 1/escala1\n\n  #Cria as bins como uma lista com todas as divis\u00f5es\n  bins =[]\n  cont = 1\n  for i in range(0,25):\n    bins.append(i)\n    while cont < escala1:\n        bins.append(bins[len(bins)-1]+(passo))\n        cont+=1\n    cont=1\n\n  #Fim defini\u00e7\u00f5es histograma esquerda\n\n  #Defini\u00e7\u00f5es histograma direita\n  duracao2 = duracao2.split()\n  duracao2 = int(duracao2[0])\n  if duracao2 == 1:\n    duracao2 = 60\n\n  escala2 = 60/duracao2\n  passo = 1/escala2\n\n  bins2 =[]\n  cont = 1\n  for i in range(0,25):\n    bins2.append(i)\n    while cont < escala2:\n        bins2.append(bins2[len(bins2)-1]+(passo))\n        cont+=1\n    cont=1\n\n  #fim defini\u00e7\u00f5es histograma direita\n\n  escala = min(escala1,escala2)\n\n  #Escala autom\u00e1tica\n  if mesmaEscala:\n    #encaixa os valores de horarios em suas posi\u00e7\u00f5es dependendo do proprio horario\n    distribuicao = [0]*24*int(escala)\n\n    for valor in valores:\n      valor %= 24\n      valor *= escala\n      distribuicao[int((valor//1))] += 1\n      valor /= escala\n    distribuicao2 = distribuicao.copy()\n    distribuicao1 = distribuicao.copy()\n  else:\n    distribuicao1 = [0]*24*int(escala1)\n    distribuicao2 = [0]*24*int(escala2)\n    for valor in valores:\n      valor %= 24\n      valor *= escala1\n      distribuicao1[int((valor//1))] += 1\n      valor /= escala1\n      valor *= escala2\n      distribuicao2[int((valor//1))] += 1\n      valor /= escala2\n\n  eixo_x1 = max(distribuicao1) + 1\n  eixo_x2 = max(distribuicao2) + 1\n\n\n  #Igual para ambos\n  escala = max(escala1,escala2)\n  duracao = 60/escala\n  passo = 1/escala\n  #Formata os major positions - inteiros e de 0 a 23 e os minor positions -- dependem da escala (0,5 0,25 ou 0,75)\n  major_positions=list(range(0,25))\n  minor_positions=[]\n  cont = 1\n  for major_position in major_positions:\n      while cont < escala:\n        minor_positions.append(major_position+cont*passo)\n        cont+=1\n      cont=1\n\n  #Formata os ticks que aparecem na tela como horas\n  major_hora = []\n  minor_hora = []\n  cont = 1\n  i=0\n  while len(major_hora)<=24:\n    major_hora.append(str(i)+':'+\"00\")\n\n    if len(major_hora)<=24:\n      while cont<escala:\n        if cont*duracao == 30:\n          minor_hora.append(str(i)+\":30\")\n        else:\n          minor_hora.append('')\n        cont+=1\n    cont=1\n    i+=1\n  # plot:\n  #fig = plt.figure(figsize=(8,10), facecolor='lightblue')\n  #ax[0] = fig.add_axes([2,4,2,8])\n  #ax[1] = fig.add_axes([4,6,2,8])\n  fig, ax = plt.subplots(1,2,figsize=(8,10), sharey=True)\n\n  #Histograma esquerdo\n  #Cria o histograma na horizontal esquerdo\n  ax[0].hist(valores, bins, height=1/escala1,weights=-np.ones_like(valores), linewidth=0.5, edgecolor=\"white\", orientation = \"horizontal\", color = grafico2)#valores = valores a serem sorteados, bins = quais as divis\u00f5es\n  #Habilita o grid\n  ax[0].grid(visible = True, which = 'major', axis = 'y')\n\n  #formata os ticks\n  ax[0].tick_params(which='major', labelsize= 10, width=1.0, length=7)\n  ax[0].tick_params(which='minor', labelsize = 8,  width=0.75, length=2.5)\n\n  #Fixa a posi\u00e7\u00e3o dos ticks\n  ax[0].yaxis.set_major_locator(ticker.FixedLocator(major_positions))\n  ax[0].yaxis.set_major_formatter(ticker.FixedFormatter(major_hora))\n\n  #Define o texto dos ticks\n  ax[0].yaxis.set_minor_locator(ticker.FixedLocator(minor_positions))\n  ax[0].yaxis.set_minor_formatter(ticker.FixedFormatter(minor_hora))\n\n  #Arruma o eixo x - pois est\u00e1 negativo\n  ax[0].xaxis.set_major_locator(ticker.FixedLocator(range(-eixo_x1, 0)))\n\n  #Arruma para que todo eixo seja positivo\n  valor  = []\n  for i in range(-eixo_x1, 0):\n    valor.append(abs(i))\n\n  ax[0].xaxis.set_major_formatter(ticker.FixedFormatter(valor))\n\n  ax[0].set_xlim(-eixo_x1, 0)\n  ax[0].set_ylim(-0.5, 24.5)\n\n  #Cria o histograma na horizontal direito\n  ax[1].hist(valores, bins2, height=1/escala2, linewidth=0.5, edgecolor=\"white\", orientation = \"horizontal\", color = grafico1)\n  #Habilita o grid\n  ax[1].grid(visible = True, which = 'major', axis = 'y')\n\n  #formata os ticks\n  ax[1].tick_params(which='major', labelsize= 10, width=1.0, length=7)\n  ax[1].tick_params(which='minor', labelsize = 8,  width=0.75, length=2.5)\n\n  #Fixa a posi\u00e7\u00e3o dos ticks\n  ax[1].yaxis.set_major_locator(ticker.FixedLocator(major_positions))\n  ax[1].yaxis.set_major_formatter(ticker.FixedFormatter(major_hora))\n\n  #Define o texto dos ticks\n  ax[1].yaxis.set_minor_locator(ticker.FixedLocator(minor_positions))\n  ax[1].yaxis.set_minor_formatter(ticker.FixedFormatter(minor_hora))\n\n  #Define a posi\u00e7\u00e3o e valor do eixo x\n  ax[1].xaxis.set_major_locator(ticker.FixedLocator(range(0, eixo_x2+1)))\n  ax[1].xaxis.set_major_formatter(ticker.FixedFormatter(range(0, eixo_x2+1)))\n\n  ax[1].set_xlim(0,eixo_x2)\n  ax[1].set_ylim(-0.5, 24.5)\n\n  # Adjust spacing\n  plt.subplots_adjust(left=0.1, right=0.9,\n                      top=0.9, bottom=0.1,\n                      wspace=0.0) #A dist\u00e2ncia pra ficar s\u00f3 ticks entre eles \u00e9 0.035\n\n  plt.show()\n\n  #Cria e formata o menu de um gr\u00e1fico \u00fanico\ndef graficoUnico ():\n    #Menu com:\n    #Check p/ ajustar propor\u00e7\u00e3o\n    #Slider p/ dura\u00e7\u00e3o\n    #Caixa de texto p/ horarios\n    #Botao de atualizar\n    #Botao de voltar\n\n    #Check de ajustar propor\u00e7\u00e3o\n    check = widgets.Checkbox(value=False,\n                          description='Ajustar Propor\u00e7\u00e3o',\n                          disabled=False,\n                          indent=False\n                          )\n    #caixa de texto para hor\u00e1rios\n    text = widgets.Text(\n                        value='',\n                        placeholder='00:00 01:00 ...',\n                        description='',\n                        disabled=False\n                        )\n\n    #Duracao - slider para selecionar o intervalo\n    slider = widgets.SelectionSlider(options=['15 minutos','20 minutos', '30 minutos', '1 hora'],\n                                     value= '1 hora',\n                                     description='',\n                                     disabled=False,\n                                     continuous_update=False,\n                                     orientation='horizontal',\n                                     readout=True\n                                     )\n    #Botao de atualizar\n    button = widgets.Button(description=\"Enviar hor\u00e1rios\")\n    #botao de voltar\n    voltar = widgets.Button(description=\"Voltar\")\n    #Caixa para permitir a organiza\u00e7\u00e3o\n    caixa1 = widgets.Box(\n        [\n            widgets.Label(value='Insira os horarios de \u00f4nibus:'),\n            text,\n            button\n        ]\n    )\n    #caixa para permitir a organiza\u00e7\u00e3o\n    caixa2 = widgets.Box(\n        [\n            widgets.Label(value='Selecione o intervalo:'),\n            slider,\n        ]\n    )\n    out = widgets.Output(wait = True) #Cria um ambiente de exposi\u00e7\u00e3o\n    display (out)\n    with out:\n      display(caixa1, caixa2, check, voltar)\n\n    outGraf = widgets.Output()\n    display(outGraf)\n\n    def on_button_clicked(button): #Quando o bot\u00e3o de enviar for apertado, limpa a \u00e1rea do gr\u00e1fico e chama um novo grafico com os valores mais atualizados\n      outGraf.clear_output(wait = True)\n      with outGraf:\n        hist_vertical(valores=tratamento(novo = text.value), duracao = slider.value, escalaAutomatica = check.value)\n\n    def on_voltar_clicked(voltar): #Quando o bot\u00e3o de voltar for apertado, limpa toda a \u00e1rea e volta ao menu principal\n      out.clear_output()\n      outGraf.clear_output()\n      principal()\n\n    def valueChange(change): #Quando qualquer valor for alterado, limpa a area do gr\u00e1fico e cria um novo gr\u00e1fico com os valores atualizados\n      outGraf.clear_output(wait = True)\n      with outGraf:\n        hist_vertical(valores=tratamento(novo = text.value), duracao = slider.value, escalaAutomatica = check.value)\n\n    check.observe(valueChange, names= \"value\")\n    slider.observe(valueChange, names= \"value\")\n    voltar.on_click(on_voltar_clicked)\n    button.on_click(on_button_clicked)\n\n#Define e formata as op\u00e7\u00f5es de um gr\u00e1fico comparativo -- dois histogramas\ndef graficoComp ():\n    #Menu com:\n    #Escala fixa ou autom\u00e1tica\n    #2 Slider p/ dura\u00e7\u00e3o\n    #Caixa de texto p/ horarios\n    #Botao de atualizar\n    #Botao de voltar?\n\n    #escala\n    check = widgets.Checkbox(value=False,\n                          description='Mesma Propor\u00e7\u00e3o',\n                          disabled=False,\n                          indent=False\n                          )\n    #caixa de texto\n    text = widgets.Text(value='',\n                        placeholder='00:00 01:00 ...',\n                        description='',\n                        disabled=False\n                        )\n    #Dura\u00e7\u00e3o 1\n    slider1 = widgets.SelectionSlider(options=['15 minutos','20 minutos', '30 minutos', '1 hora'],\n                                     value= '1 hora',\n                                     description='',\n                                     disabled=False,\n                                     continuous_update=False,\n                                     orientation='horizontal',\n                                     readout=True\n                                     )\n    #Dura\u00e7\u00e3o 2\n    slider2 = widgets.SelectionSlider(options=['15 minutos','20 minutos', '30 minutos', '1 hora'],\n                                     value= '1 hora',\n                                     description='',\n                                     disabled=False,\n                                     continuous_update=False,\n                                     orientation='horizontal',\n                                     readout=True)\n    #Botao de atualizar\n    button = widgets.Button(description=\"Enviar hor\u00e1rios\")\n    #botao de voltar\n    voltar = widgets.Button(description=\"Voltar\")\n    caixa1 = widgets.Box(\n        [\n            widgets.Label(value='Insira os horarios de \u00f4nibus:'),\n            text,\n            button\n        ]\n    )\n    caixa2 = widgets.Box(\n        [\n            widgets.Label(value='Intervalo do gr\u00e1fico da esquerda:'),\n            slider1,\n            widgets.Label(value='   Intervalo do gr\u00e1fico da direita:'),\n            slider2,\n        ]\n    )\n    out = widgets.Output()\n    display (out)\n    with out:\n      display(caixa1, caixa2, check, voltar)\n\n    outGraf = widgets.Output()\n    display(outGraf)\n    def on_button_clicked(button):#Quando o bot\u00e3o de enviar for apertado, limpa a \u00e1rea do gr\u00e1fico e chama um novo grafico com os valores mais atualizados\n      outGraf.clear_output(wait = True)\n      with outGraf:\n        hist_horizontal_comparativo(valores = tratamento(novo = text.value), duracao1 = slider1.value, duracao2 = slider2.value, mesmaEscala=check.value)\n\n    def on_voltar_clicked(voltar): #Quando o bot\u00e3o de voltar for apertado, limpa toda a \u00e1rea e volta ao menu principal\n      out.clear_output()\n      outGraf.clear_output()\n      principal()\n\n    def valueChange(change): #Quando qualquer valor for alterado, limpa a area do gr\u00e1fico e cria um novo gr\u00e1fico com os valores atualizados\n      outGraf.clear_output(wait = True)\n      with outGraf:\n        hist_horizontal_comparativo(valores = tratamento(novo = text.value), duracao1 = slider1.value, duracao2 = slider2.value, mesmaEscala=check.value)\n\n    check.observe(valueChange, names= \"value\")\n    slider1.observe(valueChange, names= \"value\")\n    slider2.observe(valueChange, names= \"value\")\n    voltar.on_click(on_voltar_clicked)\n    button.on_click(on_button_clicked)\n\n\ndef delta_tempo(valores, intervalo):\n\n  #organiza\u00e7\u00e3o dos hor\u00e1rios por ordem crescente\n  valores.sort()\n  if len(valores) == 0:\n    valores = [0]\n  valores = [0]+valores+[24+valores[0]]#Adiciona 0 e 24 mais primeiro valor, pra funcinar nas bordas\n  #Cria\u00e7\u00e3o do gr\u00e1fico e do seu tamanho\n  fig, ax = plt.subplots(figsize=(18, 5))\n\n  axes1 = fig.add_subplot(111)\n  for i in range(0,len(valores)-1):\n    #Plot de cada subconjunto do gr\u00e1fico com o horario e o horario seguinte sendo o eixo x e o eixo y sendo o valor da diferen\u00e7a at\u00e9 0\n    axes1.plot ([valores[i], valores[i+1]],[(valores[i+1]-valores[i]), 0], color = grafico1)\n\n  duracao = 1\n  escala = 1\n  axes2 = plt.axes([.475, .45, .4, .4])\n\n  #axes1 \u00e9 o gr\u00e1fico maior\n  #axes2 \u00e9 o gr\u00e1fico menor\n\n  plt.setp(ax, xticks=[], yticks=[])\n  valores_intervalo = [intervalo[0]] #Lista com todos os valores de dentro do intervalo\n  for valor in valores:\n    if valor > intervalo[0] and valor < intervalo[1]:\n      valores_intervalo.append(valor)\n    elif valor >= intervalo[1]:\n      valores_intervalo.append(valor)\n      break\n\n  for i in range(0,len(valores)-1):\n    #Plot de cada subconjunto do gr\u00e1fico com o horario e o horario seguinte sendo o eixo x e o eixo y sendo o valor da diferen\u00e7a at\u00e9 0\n    axes2.plot ([valores[i], valores[i+1]],[(valores[i+1]-valores[i]), 0], color = grafico1)\n    #Plot de pontos na absissa de cada horario em que sai um onibus\n    axes2.plot (valores[i],0, marker = 'o', color = pontos)\n\n  media = sum([(valores_intervalo[i+1]-valores_intervalo[i])**2/2 for i in range(len(valores_intervalo)-1)]) #soma dos valores de dentro do intervalo\n  media -= (valores_intervalo[-1] - intervalo[1])**2/2 #Tirar o triangulo do final\n  media /= (intervalo[1]-intervalo[0]) #Dividido pela \u00e1rea\n\n\n  #Plot da linha de m\u00e9dia\n  axes2.plot((intervalo[0], intervalo[-1]), [media]*2, color = media_cor)\n\n  #Formata os ticks que aparecem na tela como horas\n  #Posi\u00e7\u00e3o das horas\n  major_positions=list(range(0,25))\n  cont =1\n  major_positions2 = list(range(0,25))\n  minor_positions2 = []\n  #Major_positions s\u00e3o as horas, passa por todas as horas e adiciona em minor_positions todas as divis\u00f5es necess\u00e1rias\n  for major_position in major_positions2:\n      while cont < 1:\n        minor_positions2.append(major_position+cont*0.5)\n        cont+=1\n      cont=1\n\n  #Valores que aparecem na tela\n  major_hora = []\n  minor_hora = []\n  i=0\n\n  while len(major_hora)<25:\n    major_hora.append(str(i)+':'+\"00\")\n    i+=1\n\n  #seta os ticks do gr\u00e1fico maior no formato\n  axes1.tick_params(which='major', labelsize= 10, width=1.0, length=9)\n  axes1.tick_params(which='minor', labelsize = 8,  width=0.75, length=2.5)\n\n  #Fixa a posi\u00e7\u00e3o dos ticks nos eixos do gr\u00e1fico maior\n  axes1.xaxis.set_major_locator(ticker.FixedLocator(major_positions))\n  axes1.xaxis.set_major_formatter(ticker.FixedFormatter(major_hora))\n\n  #formata os ticks do gr\u00e1fico menor\n  axes2.tick_params(which='major', labelsize= 10, width=1.0, length=9)\n  axes2.tick_params(which='minor', labelsize = 8,  width=0.75, length=2.5)\n\n  max_y = []\n  for i  in range(len(valores)-1):\n    if valores[i] >= intervalo[0] and valores[i] <= intervalo[-1]:\n      if len(max_y) == 0:\n        max_y.append(valores[i] - intervalo[0])\n      else:\n        max_y.append(valores[i+1]-valores[i])\n\n  i=0\n  while valores[i]<intervalo[-1]:\n    i += 1\n\n  if max_y == []:\n    max_y = [0,max(valores[i]-intervalo[0],media)]\n  axes2.set_ylim(0, max(max_y)+max(max_y)/10)\n  axes2.set_xlim(intervalo[0], intervalo[-1])\n\n  axes2.text((intervalo[-1] - ((intervalo[-1]-intervalo[0])/2)),(media + (max(max_y)/40)), \"Tempo m\u00e9dio de espera no intervalo selecionado\", color = palavras)\n\n  def float_para_hora(y, pos):\n    return f'{int(y):02d}:{int((y-int(y))*60):02d}'\n\n  axes2.yaxis.set_major_formatter(float_para_hora)\n  axes1.yaxis.set_major_formatter(float_para_hora)\n\n  axes2.xaxis.set_major_formatter(float_para_hora)\n\n  max_y = []\n  for i in range(0,len(valores)-1):\n    max_y.append(valores[i+1]-valores[i])\n  if max_y == []:\n    max_y = [0,24]\n  axes1.set_ylim(0,max(max_y)+max(max_y)/10)\n  axes1.set_xlim(0, 24.5)\n\n  #Indicadores s\u00e3o as linhas que ligam o gr\u00e1fico menor e a maior\n  indicadores =  axes1.indicate_inset_zoom(inset_ax = axes2, edgecolor='black')\n\n  indicadores.connectors[0].set_visible(True)\n  indicadores.connectors[1].set_visible(False)\n  indicadores.connectors[2].set_visible(True)\n  indicadores.connectors[3].set_visible(False)\n\n  plt.show()\n\n#Cria e formata o menu de um gr\u00e1fico \u00fanico\ndef graficoDelta ():\n    #Menu com:\n    #Slider p/ dura\u00e7\u00e3o\n    #Caixa de texto p/ horarios\n    #Botao de atualizar\n    #Botao de voltar\n\n    #caixa de texto\n    text = widgets.Text(\n                        value='',\n                        placeholder='00:00 01:00 ...',\n                        description='',\n                        disabled=False\n                        )\n\n    #Duracao\n    slider = widgets.FloatRangeSlider(\n                                      value=[0,24],\n                                      min=0,\n                                      max=24.0,\n                                      step=0.25,\n                                      description='',\n                                      disabled=False,\n                                      continuous_update=False,\n                                      orientation='horizontal',\n                                      readout=False,\n                                     )\n\n    #Botao de atualizar\n    button = widgets.Button(description=\"Enviar hor\u00e1rios\")\n    #botao de voltar\n    voltar = widgets.Button(description=\"Voltar\")\n    def float_para_hora(y):\n      return f'{int(y):02d}:{int((y-int(y))*60):02d}'\n    def caixa2():\n      hora_inicio = widgets.Label(value= float_para_hora(slider.value[0]))\n      hora_fim = widgets.Label(value= float_para_hora(slider.value[1]))\n      caixa2 = widgets.Box(  #Caixa 2 com o slider\n        [\n            widgets.Label(value='Selecione o intervalo:'),\n            slider,\n            hora_inicio,\n            hora_fim\n        ]\n      )\n      return caixa2\n    #Caixas organizam os widgets na tela\n    caixa1 = widgets.Box( #Caixa 1 com a caixa de texto e o botao\n        [\n            widgets.Label(value='Insira os horarios de \u00f4nibus:'),\n            text,\n            button\n        ]\n    )\n    caixa3 = widgets.Box(  #Caixa 3 com o botao de voltar\n        [\n            voltar\n        ]\n    )\n    out = widgets.Output(wait = True)\n    display (out)\n    with out:\n      display(caixa1)\n\n    outGraf = widgets.Output()\n    display(outGraf)\n    with outGraf:\n      display(caixa2(),caixa3)\n\n    def on_button_clicked(button): #Quando o bot\u00e3o de enviar for apertado, limpa a \u00e1rea do gr\u00e1fico e chama um novo grafico com os valores mais atualizados\n      outGraf.clear_output(wait = True)\n      if text.value == '':\n        outGraf.clear_output(wait = True)\n        with outGraf:\n          display(caixa2(),caixa3)\n          display('Este \u00e9 o gr\u00e1fico de espera sem nenhum hor\u00e1rio de \u00f4nibus')\n      else:\n        outGraf.clear_output(wait = True)\n        with outGraf:\n          display(caixa2(),caixa3)\n      with outGraf:\n        delta_tempo(valores=tratamento(novo = text.value), intervalo = slider.value)\n\n    def on_voltar_clicked(voltar): #Quando o bot\u00e3o de voltar for apertado, limpa toda a \u00e1rea e volta ao menu principal\n      out.clear_output()\n      outGraf.clear_output()\n      principal()\n\n    def valueChange(change): #Quando qualquer valor for alterado, limpa a area do gr\u00e1fico e cria um novo gr\u00e1fico com os valores atualizados\n      outGraf.clear_output(wait = True)\n\n      validador = True\n      if slider.value[0] == slider.value[1]:\n        validador = False\n        slider.value = [0,24]\n        outGraf.clear_output(wait = True)\n        with outGraf:\n          display(caixa2(),caixa3)\n          display('Os valores de m\u00e1ximo e de m\u00ednimo n\u00e3o podem ser iguais')\n\n      if text.value == '':\n        outGraf.clear_output(wait = True)\n        with outGraf:\n          display(caixa2(),caixa3)\n          display('Este \u00e9 o gr\u00e1fico de espera sem nenhum hor\u00e1rio de \u00f4nibus')\n      else:\n        if validador:\n          outGraf.clear_output(wait = True)\n          with outGraf:\n            display(caixa2(),caixa3)\n\n      with outGraf:\n        delta_tempo(valores=tratamento(novo = text.value), intervalo = slider.value)\n\n    slider.observe(valueChange, names= \"value\")\n    voltar.on_click(on_voltar_clicked)\n    button.on_click(on_button_clicked)\n\n#Cria e formata o menu principal\nchoice = widgets.Dropdown(options=[('Selecione...', 1), ('Gr\u00e1fico \u00fanico', 2), ('Gr\u00e1fico Comparativo', 3), ('Gr\u00e1fico de Tempo de Espera', 4) ],\n                        value= 1,\n                        description='',\n                        )\nout = widgets.Output()\ndisplay(out)\ncaixa = widgets.Box(\n    [\n        widgets.Label(value='Selecione o tipo de gr\u00e1fico:'),\n        choice\n    ]\n)\nwith out:\ndisplay(caixa)\n\ndef valueChangeChoice(change): #Quando o valor do menu mudar chama a fun\u00e7\u00e3o\nwith out:\n    if change['new'] == 2: #Se for gr\u00e1fico \u00fanico, chama o menu de gr\u00e1fico \u00fanico\n    out.clear_output(wait = True)\n    graficoUnico()\n    elif change['new'] == 3: #Se for gr\u00e1fico comparativo, chama o menu de gr\u00e1fico comparativo\n    out.clear_output(wait = True)\n    graficoComp()\n    elif change['new'] == 4: #Se for gr\u00e1fico de tempo de espera, chama o menu de tempo de espera\n    out.clear_output(wait = True)\n    graficoDelta()\n\nchoice.observe(valueChangeChoice, names='value')", "type": "text"}, {"name": "imagens/Cienvolva.jpeg", "content": "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", "type": "binary"}]